<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>çº¢åŒ…é›¨ Â· ç®¡ç†æ§åˆ¶å°</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&family=Noto+Sans+SC:wght@400;500;700&display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #0b1118;
      --panel: #111827;
      --panel-2: #0f172a;
      --border: rgba(148, 163, 184, 0.15);
      --text: #e2e8f0;
      --muted: #94a3b8;
      --accent: #f4d35e;
      --accent-2: #37e2c9;
      --danger: #ff6b6b;
      --success: #4ade80;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Space Grotesk', 'Noto Sans SC', sans-serif;
      color: var(--text);
      background: radial-gradient(circle at top, rgba(56, 189, 248, 0.15), transparent 60%),
        radial-gradient(circle at 20% 20%, rgba(244, 211, 94, 0.2), transparent 50%),
        var(--bg);
      min-height: 100vh;
    }

    .app {
      max-width: 1280px;
      margin: 0 auto;
      padding: 32px 20px 48px;
    }

    .header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
      margin-bottom: 24px;
    }

    .brand h1 {
      font-size: 28px;
      margin: 0;
      letter-spacing: 0.5px;
    }

    .brand p {
      margin: 6px 0 0;
      color: var(--muted);
      font-size: 14px;
    }

    .chips {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
    }

    .chip {
      padding: 6px 12px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.6);
      color: var(--text);
    }

    .chip.ok {
      border-color: rgba(74, 222, 128, 0.3);
      color: var(--success);
    }

    .chip.warn {
      border-color: rgba(248, 113, 113, 0.4);
      color: var(--danger);
    }

    .grid {
      display: grid;
      gap: 16px;
    }

    .grid.stats {
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
    }

    .grid.split {
      grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
    }

    .grid.main {
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
    }

    @media (max-width: 960px) {
      .grid.main {
        grid-template-columns: 1fr;
      }
    }

    .card {
      background: linear-gradient(160deg, rgba(17, 24, 39, 0.95), rgba(15, 23, 42, 0.95));
      border: 1px solid var(--border);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
    }

    .card h2 {
      margin: 0 0 12px;
      font-size: 15px;
      letter-spacing: 0.3px;
      color: #f8fafc;
    }

    .card .meta {
      color: var(--muted);
      font-size: 12px;
    }

    .stat-value {
      font-size: 32px;
      font-weight: 600;
      margin: 8px 0 4px;
    }

    .stat-sub {
      color: var(--muted);
      font-size: 12px;
    }

    .btn {
      border: none;
      background: rgba(148, 163, 184, 0.12);
      color: var(--text);
      padding: 10px 16px;
      border-radius: 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.2s ease;
    }

    .btn:hover {
      filter: brightness(1.1);
    }

    .btn:active {
      transform: scale(0.98);
    }

    .btn.primary {
      background: linear-gradient(135deg, rgba(244, 211, 94, 0.95), rgba(243, 132, 34, 0.9));
      color: #1f2937;
      font-weight: 600;
    }

    .btn.secondary {
      background: linear-gradient(135deg, rgba(55, 226, 201, 0.85), rgba(59, 130, 246, 0.8));
      color: #0f172a;
      font-weight: 600;
    }

    .btn.ghost {
      background: transparent;
      border: 1px solid var(--border);
    }

    .btn.danger {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid rgba(239, 68, 68, 0.4);
      color: #fecaca;
    }

    .form-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 12px;
    }

    label {
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
      display: block;
    }

    input,
    select,
    textarea {
      width: 100%;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: var(--text);
      border-radius: 10px;
      padding: 10px 12px;
      font-size: 13px;
    }

    textarea {
      resize: vertical;
      min-height: 80px;
    }

    details {
      margin-top: 12px;
      border: 1px dashed rgba(148, 163, 184, 0.2);
      padding: 12px;
      border-radius: 12px;
    }

    summary {
      cursor: pointer;
      font-size: 12px;
      color: var(--muted);
    }

    .list {
      display: grid;
      gap: 8px;
    }

    .list-item {
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.15);
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
    }

    .lock-tools {
      display: flex;
      gap: 10px;
      align-items: center;
      margin-top: 10px;
    }

    .lock-tools input[type="text"] {
      flex: 1;
    }

    .lock-select {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      white-space: nowrap;
    }

    .lock-check {
      display: flex;
      align-items: center;
      gap: 10px;
      width: 100%;
      cursor: pointer;
    }

    .lock-check input {
      width: 20px !important;
      height: 20px !important;
      flex: 0 0 20px;
      max-width: 20px !important;
      min-width: 20px !important;
      padding: 0 !important;
      margin: 0 !important;
      background: transparent !important;
      border: none !important;
      box-sizing: border-box;
      appearance: auto;
      accent-color: #37e2c9;
    }

    .lock-list .list-item {
      justify-content: flex-start;
      align-items: center;
    }

    .lock-list .lock-check {
      flex: 1;
    }

    .lock-list .user-line {
      align-items: center;
      gap: 10px;
    }

    .lock-list input[type="checkbox"] {
      width: 20px !important;
      height: 20px !important;
      min-width: 20px !important;
      max-width: 20px !important;
      padding: 0 !important;
      margin: 0 !important;
      display: inline-block;
    }

    .round-result-tools {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .round-result-tools input {
      width: 220px;
      max-width: 220px;
      flex: 0 0 220px;
    }

    .progress {
      height: 6px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.15);
      overflow: hidden;
    }

    .progress span {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, rgba(55, 226, 201, 0.9), rgba(244, 211, 94, 0.9));
    }

    .note {
      font-size: 12px;
      color: var(--muted);
    }

    .pill {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
      color: var(--muted);
    }

    .pill.ok {
      border-color: rgba(74, 222, 128, 0.35);
      color: var(--success);
    }

    .pill.warn {
      border-color: rgba(244, 211, 94, 0.4);
      color: var(--accent);
    }

    .pill.danger {
      border-color: rgba(248, 113, 113, 0.45);
      color: var(--danger);
    }

    .result-box {
      width: 100%;
      min-height: 120px;
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 184, 0.2);
      background: rgba(15, 23, 42, 0.7);
      color: var(--text);
      padding: 10px;
      font-size: 12px;
      font-family: 'Space Grotesk', 'Noto Sans SC', sans-serif;
    }

    .footer-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-top: 16px;
    }

    .modal {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(2, 6, 23, 0.9);
      z-index: 99;
    }

    .modal.active {
      display: flex;
    }

    .modal .card {
      width: min(560px, 90vw);
    }

    canvas {
      width: 100%;
      height: 110px;
    }

    .tab-bar {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 18px;
    }

    .tab-btn {
      border: 1px solid var(--border);
      background: rgba(15, 23, 42, 0.75);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 12px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.08s ease, filter 0.2s ease, background 0.2s ease;
    }

    .tab-btn.active {
      background: linear-gradient(135deg, rgba(55, 226, 201, 0.85), rgba(244, 211, 94, 0.9));
      color: #0f172a;
      font-weight: 600;
      border-color: transparent;
    }

    .tab-panel {
      display: none;
      animation: tabFade 0.35s ease;
    }

    .tab-panel.active {
      display: block;
    }

    @keyframes tabFade {
      from {
        opacity: 0;
        transform: translateY(8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .switch {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 13px;
    }

    .switch input {
      appearance: none;
      width: 42px;
      height: 22px;
      border-radius: 999px;
      background: rgba(148, 163, 184, 0.2);
      position: relative;
      cursor: pointer;
      outline: none;
      transition: background 0.2s ease;
    }

    .switch input::after {
      content: '';
      position: absolute;
      top: 3px;
      left: 3px;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #f8fafc;
      transition: transform 0.2s ease;
    }

    .switch input:checked {
      background: rgba(74, 222, 128, 0.6);
    }

    .switch input:checked::after {
      transform: translateX(20px);
    }

    .user-line {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .avatar {
      width: 28px;
      height: 28px;
      border-radius: 50%;
      object-fit: cover;
      background: rgba(148, 163, 184, 0.25);
      color: #0f172a;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      font-size: 12px;
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .avatar.large {
      width: 42px;
      height: 42px;
      font-size: 16px;
    }

    .avatar.mini {
      width: 22px;
      height: 22px;
      font-size: 10px;
    }

    .avatar.fallback {
      background: linear-gradient(135deg, hsl(var(--avatar-hue, 200), 70%, 70%), hsl(calc(var(--avatar-hue, 200) + 30), 65%, 45%));
      color: #0b1020;
    }

    .status-tag {
      padding: 3px 8px;
      border-radius: 999px;
      font-size: 11px;
      border: 1px solid var(--border);
      color: var(--muted);
    }

    .status-tag.ok {
      border-color: rgba(74, 222, 128, 0.35);
      color: var(--success);
    }

    .status-tag.warn {
      border-color: rgba(244, 211, 94, 0.4);
      color: var(--accent);
    }

    .status-tag.danger {
      border-color: rgba(248, 113, 113, 0.45);
      color: var(--danger);
    }

    .flow-box {
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .flow-step {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.15);
      font-size: 13px;
    }

    .big-screen {
      position: fixed;
      inset: 0;
      background: radial-gradient(circle at top, rgba(59, 130, 246, 0.2), transparent 55%),
        radial-gradient(circle at 20% 30%, rgba(244, 211, 94, 0.25), transparent 60%),
        #05070d;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 200;
      color: #f8fafc;
    }

    .big-screen.active {
      display: flex;
    }

    .big-shell {
      width: min(1280px, 92vw);
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 24px;
    }

    .big-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 16px;
    }

    .big-title {
      font-size: clamp(28px, 4vw, 48px);
      font-weight: 700;
      letter-spacing: 1px;
    }

    .big-status {
      font-size: 14px;
      color: rgba(248, 250, 252, 0.7);
    }

    .big-countdown {
      font-size: clamp(64px, 10vw, 140px);
      font-weight: 700;
      text-align: center;
      letter-spacing: 3px;
      color: #f4d35e;
      text-shadow: 0 0 20px rgba(244, 211, 94, 0.4);
      animation: pulse 1.2s ease-in-out infinite;
    }

    .big-grid {
      display: grid;
      gap: 18px;
      grid-template-columns: minmax(0, 2fr) minmax(0, 1fr);
    }

    @media (max-width: 980px) {
      .big-grid {
        grid-template-columns: 1fr;
      }
    }

    .big-card {
      background: rgba(15, 23, 42, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.25);
      border-radius: 18px;
      padding: 18px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.35);
    }

    .big-card h3 {
      margin: 0 0 12px;
      font-size: 16px;
      color: #f8fafc;
    }

    .big-list {
      display: grid;
      gap: 10px;
      max-height: 420px;
      overflow: auto;
    }

    .race-track {
      position: relative;
      border-radius: 16px;
      padding: 12px;
      background: linear-gradient(135deg, rgba(6, 10, 20, 0.9), rgba(10, 16, 30, 0.9));
      border: 1px solid rgba(148, 163, 184, 0.2);
      min-height: 420px;
    }

    .race-segments {
      position: absolute;
      inset: 12px;
      pointer-events: none;
    }

    .race-segment-line {
      position: absolute;
      top: 0;
      bottom: 0;
      width: 1px;
      background: rgba(148, 163, 184, 0.15);
    }

    .race-segment-label {
      position: absolute;
      top: -18px;
      font-size: 10px;
      color: rgba(248, 250, 252, 0.55);
      transform: translateX(-50%);
    }

    .race-lanes {
      position: relative;
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 520px;
      overflow: auto;
    }

    .race-lanes.cols-2 {
      display: grid;
      grid-template-columns: repeat(2, minmax(260px, 1fr));
      grid-auto-rows: auto;
      align-content: start;
    }

    .race-lanes.cols-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(220px, 1fr));
      grid-auto-rows: auto;
      align-content: start;
    }

    .race-lane {
      position: relative;
      height: 42px;
      border-radius: 12px;
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid rgba(148, 163, 184, 0.12);
      overflow: hidden;
    }

    .race-lane::after {
      content: '';
      position: absolute;
      inset: 0;
      background: repeating-linear-gradient(90deg, rgba(148, 163, 184, 0.08), rgba(148, 163, 184, 0.08) 6px, transparent 6px, transparent 18px);
      opacity: 0.5;
    }

    .race-car {
      position: absolute;
      top: 50%;
      left: 0;
      transform: translate(0, -50%);
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(3, 7, 18, 0.75);
      border: 1px solid rgba(148, 163, 184, 0.25);
      box-shadow: 0 6px 16px rgba(0, 0, 0, 0.35);
      transition: transform 0.3s ease;
      z-index: 2;
    }

    .race-track.compact .race-lane {
      height: 34px;
    }

    .race-track.compact .race-car {
      gap: 6px;
      padding: 2px 6px;
    }

    .race-track.compact .race-score {
      font-size: 11px;
    }

    .race-track.compact .race-rank {
      min-width: 24px;
      font-size: 10px;
    }

    .race-track.compact .avatar {
      width: 22px;
      height: 22px;
      font-size: 10px;
    }

    .race-track.dense .race-lane {
      height: 30px;
    }

    .race-track.dense .race-car {
      gap: 4px;
      padding: 2px 4px;
    }

    .race-rank {
      font-size: 11px;
      color: rgba(248, 250, 252, 0.7);
      min-width: 28px;
      text-align: center;
    }

    .race-score {
      font-size: 12px;
      color: #f4d35e;
      font-weight: 600;
    }

    .race-name {
      max-width: 160px;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      color: rgba(248, 250, 252, 0.9);
      font-size: 12px;
    }

    .race-track.compact .race-name {
      max-width: 120px;
      font-size: 11px;
    }

    .big-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      padding: 12px 14px;
      border-radius: 14px;
      background: rgba(9, 13, 24, 0.85);
      border: 1px solid rgba(148, 163, 184, 0.2);
    }

    .big-score {
      font-size: 18px;
      font-weight: 600;
      color: #37e2c9;
    }

    .big-meta {
      font-size: 13px;
      color: rgba(248, 250, 252, 0.65);
    }

    .big-actions {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    @keyframes pulse {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }

      100% {
        transform: scale(1);
      }
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(8px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    body.big-open {
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div class="app">
    <div class="header">
      <div class="brand">
        <h1>çº¢åŒ…é›¨ Â· ç®¡ç†æ§åˆ¶å°</h1>
        <p>å…¨å±€ç›‘æ§ã€è½®æ¬¡èŠ‚å¥ä¸å¼€å¥–æµç¨‹ç»Ÿä¸€åœ¨è¿™é‡Œå®Œæˆã€‚</p>
      </div>
      <div class="chips">
        <button id="followBtn" class="btn ghost" onclick="toggleFollow()">è·Ÿéšå½“å‰</button>
        <button id="bigScreenBtn" class="btn secondary" onclick="openBigScreen(true)">å¤§å±æ¨¡å¼</button>
        <div id="connStatus" class="chip warn">æœªè¿æ¥</div>
      </div>
    </div>

    <div class="tab-bar" id="tabBar">
      <button class="tab-btn active" data-tab="overview">ç›‘æ§é¢æ¿</button>
      <button class="tab-btn" data-tab="rounds">è½®æ¬¡é…ç½®</button>
      <button class="tab-btn" data-tab="users">ç”¨æˆ·ç™½åå•</button>
      <button class="tab-btn" data-tab="batches">æ‰¹æ¬¡å†å²</button>
      <button class="tab-btn" data-tab="withdraw">æç°èµ„é‡‘</button>
      <button class="tab-btn" data-tab="system">ç³»ç»Ÿè®¾ç½®</button>
    </div>

    <section class="tab-panel active" data-tab-panel="overview">
      <div class="grid stats">
        <div class="card">
          <h2>ç®¡ç†å‘˜ç™»å½•</h2>
          <label>ç®¡ç†å‘˜å¯†ç </label>
          <div class="form-row" style="grid-template-columns: 1fr auto; align-items: end;">
            <input id="adminPassword" type="password" placeholder="è¯·è¾“å…¥å¯†ç " />
            <button class="btn primary" onclick="adminLogin()">ç™»å½•</button>
          </div>
          <div id="loginTip" class="meta" style="margin-top:8px;"></div>
        </div>

        <div class="card">
          <h2>å½“å‰è½®æ¬¡</h2>
          <div class="stat-value" id="roundTitle">--</div>
          <div class="meta" id="roundMeta">çŠ¶æ€ï¼š--</div>
          <div style="margin-top:12px;">
            <div class="meta">å‰©ä½™æ—¶é—´</div>
            <div class="stat-value" id="timeLeft">--</div>
          </div>
        </div>

        <div class="card">
          <h2>åœ¨çº¿ç”¨æˆ·</h2>
          <div class="stat-value" id="onlineCount">0</div>
          <div class="progress" style="margin:10px 0;"><span id="onlineBar" style="width:0"></span></div>
          <div class="stat-sub">å‚è€ƒäººæ•°ï¼š1000</div>
        </div>

        <div class="card">
          <h2>å®æ—¶ç‚¹å‡» QPS</h2>
          <div class="stat-value" id="qpsValue">0</div>
          <div class="stat-sub">è¿‘ 5 ç§’å‡å€¼ / 1 ç§’å³°å€¼</div>
          <div class="meta" id="qpsDetail">0 / 0</div>
        </div>
      </div>

      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <h2>è¶‹åŠ¿ Â· QPS</h2>
          <div class="meta">å‡å€¼ <span id="qpsAvgText">0</span> | å³°å€¼ <span id="qpsPeakText">0</span></div>
          <canvas id="qpsChart" height="80"></canvas>
        </div>
        <div class="card">
          <h2>è¶‹åŠ¿ Â· æ’è¡Œæ¦œ Top1 åˆ†æ•°</h2>
          <canvas id="scoreChart" height="80"></canvas>
        </div>
      </div>

      <div class="grid main" style="margin-top:16px;">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>è½®æ¬¡é…ç½®</h2>
            <button class="btn ghost" onclick="copyConfig()">å¤åˆ¶é…ç½® JSON</button>
          </div>
          <div id="roundSummary" class="list" style="margin-top:12px;"></div>
        </div>

        <div class="card">
          <h2>å®æ—¶æ’è¡Œ</h2>
          <div id="leaderboard" class="list"></div>
        </div>
      </div>

    </section>

    <section class="tab-panel" data-tab-panel="rounds">
      <div class="grid main" style="margin-top:16px;">
        <div class="card" id="createRoundCard">
          <h2>å¿«é€Ÿåˆ›å»ºè½®æ¬¡</h2>
          <div class="form-row" style="margin-bottom:8px;">
            <div>
              <label>æ ‡é¢˜</label>
              <input id="title" placeholder="ä¾‹å¦‚ï¼šå¹´ä¼šçº¢åŒ…é›¨" />
            </div>
            <div>
              <label>éš¾åº¦çº§åˆ«</label>
              <select id="difficultySelect">
                <option value="easy">ğŸŒŸ ä¼‘é—²æ¨¡å¼</option>
                <option value="medium" selected>â­ æ ‡å‡†æ¨¡å¼</option>
                <option value="hard">ğŸ”¥ æŒ‘æˆ˜æ¨¡å¼</option>
                <option value="hell">ğŸ’€ åœ°ç‹±æ¨¡å¼</option>
                <option value="party">ğŸ‰ æ´¾å¯¹æ¨¡å¼</option>
              </select>
              <div style="display:flex; gap:8px; align-items:center; margin-top:8px;">
                <button id="applyPresetBtn" class="btn secondary" type="button">åº”ç”¨é¢„è®¾</button>
                <span id="presetStatus" class="meta">å½“å‰ï¼šé¢„è®¾Â·ä¸­çº§</span>
              </div>
              <div class="note" id="difficultyHint" style="margin-top:6px;"></div>
            </div>
            <div>
              <label>å¥–æ± ï¼ˆå…ƒï¼‰</label>
              <input id="totalPool" type="number" placeholder="ä¾‹å¦‚ï¼š5000" />
            </div>
            <div>
              <label>å¹¸è¿æ± æ¯”ä¾‹ï¼ˆ%ï¼‰</label>
              <input id="luckyRatioInput" type="number" value="40" />
            </div>
            <div>
              <label>åŸºç¡€æ± æ¯”ä¾‹ï¼ˆ%ï¼‰</label>
              <input id="baseRatioInput" type="number" value="60" />
            </div>
            <div>
              <label>æ¸¸æˆæ—¶é•¿ï¼ˆç§’ï¼‰</label>
              <input id="duration" type="number" value="30" />
            </div>
            <div>
              <label>å€’è®¡æ—¶ï¼ˆç§’ï¼‰</label>
              <input id="countdownInput" type="number" value="3" />
            </div>
            <div>
              <label>çº¢åŒ…æ˜¾ç¤ºæ—¶é—´ï¼ˆmsï¼‰</label>
              <input id="dropVisibleMsInput" type="number" placeholder="å»ºè®® 2200 - 3200" />
            </div>
            <div>
              <label>æ¯ç§’çº¢åŒ…æ•°</label>
              <input id="dropsPerSecInput" type="number" placeholder="ä¾‹å¦‚ 6 - 12" />
            </div>
          </div>
          <div class="note">é€‰æ‹©éš¾åº¦åç‚¹å‡»â€œåº”ç”¨é¢„è®¾â€å¡«å……å‚æ•°ï¼Œå¯å†æ‰‹åŠ¨å¾®è°ƒï¼›å¡«å†™â€œæ¯ç§’çº¢åŒ…æ•°â€ä¼šè‡ªåŠ¨æ¢ç®—æ¯ç‰‡çº¢åŒ…æ•°ã€‚</div>
          <div class="note" id="ratioHint" style="margin-top:6px;">å½“å‰åˆ†é…ï¼šå¹¸è¿æ±  40% + åŸºç¡€æ±  60%ï¼ˆå‰©ä½™ç”¨äºè¡¥å·®ï¼‰</div>

          <details open>
            <summary>é«˜çº§è®¾ç½®ï¼ˆéæ ¸å¿ƒï¼‰</summary>
            <div class="form-row" style="margin-top:12px;">
              <div>
                <label>åˆ‡ç‰‡æ—¶é•¿ï¼ˆmsï¼‰</label>
                <input id="sliceMsInput" type="number" placeholder="é»˜è®¤ 1000" />
              </div>
              <div>
                <label>æ¯ç‰‡çº¢åŒ…æ•°</label>
                <input id="dropsPerSliceInput" type="number" placeholder="é»˜è®¤æ™ºèƒ½" />
              </div>
              <div>
                <label>æ¯ç‰‡ç‚¸å¼¹æ•°</label>
                <input id="bombsPerSliceInput" type="number" placeholder="é»˜è®¤ 20%" />
              </div>
              <div>
                <label>æ¯ç‰‡å¤§çº¢åŒ…æ•°</label>
                <input id="bigsPerSliceInput" type="number" placeholder="é»˜è®¤ 0" />
              </div>
              <div>
                <label>æ¯ç‰‡ç©ºåŒ…æ•°</label>
                <input id="emptyPerSliceInput" type="number" placeholder="é»˜è®¤ 0" />
              </div>
              <div>
                <label>æ€»å¹¸è¿åˆ†</label>
                <input id="scoreTotalInput" type="number" placeholder="é»˜è®¤ 1000" />
              </div>
              <div>
                <label>ç‚¸å¼¹æ‰£åˆ†</label>
                <input id="bombPenaltyInput" type="number" placeholder="é»˜è®¤ 50" />
              </div>
              <div>
                <label>å¤§çº¢åŒ…å€ç‡</label>
                <input id="bigMultiplierInput" type="number" step="0.1" placeholder="é»˜è®¤ 2.0" />
              </div>
              <div>
                <label>é€Ÿåº¦ä¸Šé™ï¼ˆè¶Šå°è¶Šæ…¢ï¼‰</label>
                <input id="maxSpeedInput" type="number" step="0.05" placeholder="é»˜è®¤ 1.0" />
              </div>
              <div>
                <label>æœ€å°ä¸­å¥–ï¼ˆå…ƒï¼‰</label>
                <input id="minAwardInput" type="number" placeholder="å¯ç©º" />
              </div>
              <div>
                <label>æœ€å¤§ä¸­å¥–ï¼ˆå…ƒï¼‰</label>
                <input id="maxAwardInput" type="number" placeholder="å¯ç©º" />
              </div>
              <div>
                <label>å°¾å·®è¡¥å¿å‰ N å</label>
                <input id="tailTopNInput" type="number" value="3" />
              </div>
              <div>
                <label>æ’ååˆ†æ®µæ•°</label>
                <input id="rankSegmentsInput" type="number" value="10" />
              </div>
            </div>
            <div class="note" style="margin-top:8px;">æœ€å°/æœ€å¤§ä¸­å¥–å½“å‰ä¸å‚ä¸å¼€å¥–ç®—æ³•ã€‚</div>
          </details>

          <div class="footer-actions">
            <button class="btn primary" onclick="createRound()">åˆ›å»º</button>
            <button class="btn" onclick="lockRound()">é”å®š</button>
            <button class="btn secondary" onclick="startRound()">å¼€å§‹</button>
            <button class="btn danger" onclick="drawRound()">å¼€å¥–</button>
          </div>
          <div id="createResult" class="meta" style="margin-top:10px;"></div>
        </div>

        <div class="grid" style="gap:16px;">
          <div class="card">
            <h2>æµç¨‹æç¤º</h2>
            <div class="flow-box" style="margin-top:6px;">
              <div class="flow-step">
                <span id="flowStatusText">å½“å‰é˜¶æ®µï¼š--</span>
                <span id="flowStatusTag" class="status-tag">--</span>
              </div>
              <div id="flowHint" class="note">ç­‰å¾…åŠ è½½è½®æ¬¡ä¿¡æ¯...</div>
            </div>
            <div class="footer-actions">
              <button id="flowActionBtn" class="btn primary" onclick="handleFlowAction()">æ‰§è¡Œä¸‹ä¸€æ­¥</button>
              <button id="flowSecondaryBtn" class="btn ghost" onclick="handleFlowSecondary()"
                style="display:none;">æŸ¥çœ‹æ‰¹æ¬¡</button>
            </div>
          </div>
        </div>
      </div>
    </section>

    <section class="tab-panel" data-tab-panel="users">
      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>åœ¨çº¿ç”¨æˆ·</h2>
            <button class="btn ghost" onclick="loadOnlineUsers()">åˆ·æ–°</button>
          </div>
          <div class="note">è¿‘ 20 ç§’å¿ƒè·³æ´»è·ƒç”¨æˆ·</div>
          <div id="onlineUsers" class="list" style="max-height:260px; overflow:auto; margin-top:10px;"></div>
          <div class="note" style="margin-top:10px;">é”å®šåä¼šå¼¹å‡ºåœ¨çº¿ç”¨æˆ·æ¸…å•ï¼Œå¯ä¸€é”®å¯¼å…¥ç™½åå•ã€‚</div>
        </div>

        <div class="card">
          <h2>ç™½åå•å¯¼å…¥</h2>
          <label>æ‰‹æœºå·åˆ—è¡¨ï¼ˆé€—å·æˆ–æ¢è¡Œåˆ†éš”ï¼‰</label>
          <textarea id="whitelistPhones" placeholder="138xxxx, 139xxxx"></textarea>
          <button class="btn primary" onclick="addWhitelist()" style="margin-top:12px;">å¯¼å…¥</button>
        </div>
      </div>
    </section>

    <section class="tab-panel" data-tab-panel="batches">
      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <h2>å¼€å¥–æ‰¹æ¬¡</h2>
          <div id="batchList" class="list"></div>
        </div>
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>å†å²è½®æ¬¡</h2>
            <button class="btn ghost" onclick="loadRounds()">åˆ·æ–°</button>
          </div>
          <div id="roundList" class="list" style="max-height:260px; overflow:auto; margin-top:12px;"></div>
        </div>
      </div>
      <div class="card" style="margin-top:16px;">
        <div style="display:flex; justify-content:space-between; align-items:center; gap:12px; flex-wrap:wrap;">
          <h2>è½®æ¬¡ç»“æœ</h2>
          <div class="round-result-tools">
            <input id="roundResultSearch" type="text" placeholder="æ‰‹æœºå·/æ˜µç§°/ç”¨æˆ·ID" onkeydown="if(event.key==='Enter'){loadRoundResults(true)}" />
            <button class="btn ghost" onclick="loadRoundResults(true)">æœç´¢</button>
          </div>
        </div>
        <div id="roundResultSummary" class="note" style="margin-top:6px;">é€‰æ‹©å†å²è½®æ¬¡æŸ¥çœ‹</div>
        <div id="roundResultList" class="list" style="max-height:360px; overflow:auto; margin-top:10px;"></div>
        <div class="footer-actions">
          <button class="btn ghost" onclick="prevRoundResultPage()">ä¸Šä¸€é¡µ</button>
          <button class="btn ghost" onclick="nextRoundResultPage()">ä¸‹ä¸€é¡µ</button>
        </div>
      </div>
    </section>

    <section class="tab-panel" data-tab-panel="withdraw">
      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>æç°ç”³è¯·å¼€å…³</h2>
            <div class="switch">
              <input id="withdrawSwitch" type="checkbox" />
              <span id="withdrawSwitchText">æœªåŠ è½½</span>
            </div>
          </div>
          <div class="note" id="withdrawSwitchHint" style="margin-top:8px;">å…³é—­åç”¨æˆ·ç«¯å°†æ— æ³•æäº¤æ–°çš„æç°ç”³è¯·ã€‚</div>
        </div>
        <div class="card">
          <h2>æç°é˜Ÿåˆ—æç¤º</h2>
          <div class="note" id="withdrawQueueHint" style="margin-top:8px;">ç­‰å¾…åŠ è½½æç°æ•°æ®...</div>
        </div>
      </div>

      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <div style="display:flex; justify-content:space-between; align-items:center;">
            <h2>æç°ç®¡ç†</h2>
            <button class="btn ghost" onclick="loadWithdrawsAdmin(true)">åˆ·æ–°</button>
          </div>
          <div class="form-row" style="margin-top:12px;">
            <div>
              <label>çŠ¶æ€è¿‡æ»¤</label>
              <select id="withdrawStatusFilter">
                <option value="">å…¨éƒ¨</option>
                <option value="PENDING">å¾…å¤„ç†</option>
                <option value="WAITING_FUNDS">ä½™é¢ä¸è¶³ç­‰å¾…</option>
                <option value="PROCESSING">å¤„ç†ä¸­</option>
                <option value="PAID">å·²åˆ°è´¦</option>
                <option value="FAILED">å¤±è´¥</option>
                <option value="REFUNDED">å·²é€€æ¬¾</option>
              </select>
            </div>
            <div>
              <label>æ¯é¡µæ•°é‡</label>
              <select id="withdrawLimit">
                <option value="10">10</option>
                <option value="20" selected>20</option>
                <option value="50">50</option>
              </select>
            </div>
            <div>
              <label>åˆ†é¡µæ“ä½œ</label>
              <div style="display:flex; gap:8px; align-items:flex-end;">
                <button class="btn ghost" onclick="prevWithdrawPage()">ä¸Šä¸€é¡µ</button>
                <button class="btn ghost" onclick="nextWithdrawPage()">ä¸‹ä¸€é¡µ</button>
              </div>
            </div>
          </div>
          <div id="withdrawMeta" class="note" style="margin-top:10px;">ç­‰å¾…åŠ è½½...</div>
          <div id="withdrawListAdmin" class="list" style="max-height:320px; overflow:auto; margin-top:12px;"></div>
        </div>
        <div class="card">
          <h2>æ”¯ä»˜å®èµ„é‡‘æŸ¥è¯¢</h2>
          <div class="form-row" style="margin-top:12px;">
            <div>
              <label>è´¦æˆ·æŸ¥è¯¢ - Alipay User ID</label>
              <input id="alipayUserIdInput" placeholder="å¯é€‰" />
            </div>
            <div>
              <label>è´¦æˆ·ç±»å‹ account_type</label>
              <input id="alipayAccountTypeInput" placeholder="å¯é€‰" />
            </div>
            <div style="display:flex; align-items:flex-end;">
              <button class="btn secondary" onclick="queryAlipayAccount()">æŸ¥è¯¢è´¦æˆ·</button>
            </div>
          </div>
          <div id="alipayAccountSummary" class="list" style="margin-top:12px;"></div>
          <textarea id="alipayAccountResult" class="result-box" readonly placeholder="è´¦æˆ·æŸ¥è¯¢ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º"></textarea>

          <div class="form-row" style="margin-top:16px;">
            <div>
              <label>é¢åº¦æŸ¥è¯¢ product_code</label>
              <input id="alipayProductCodeInput" placeholder="é»˜è®¤ TRANS_ACCOUNT_NO_PWD" />
            </div>
            <div>
              <label>é¢åº¦æŸ¥è¯¢ biz_scene</label>
              <input id="alipayBizSceneInput" placeholder="é»˜è®¤ DIRECT_TRANSFER" />
            </div>
            <div style="display:flex; align-items:flex-end;">
              <button class="btn secondary" onclick="queryAlipayQuota()">æŸ¥è¯¢é¢åº¦</button>
            </div>
          </div>
          <textarea id="alipayQuotaResult" class="result-box" readonly placeholder="é¢åº¦æŸ¥è¯¢ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º"></textarea>

          <div class="form-row" style="margin-top:16px;">
            <div>
              <label>è½¬è´¦æµ‹è¯• - æ”¶æ¬¾è´¦å·</label>
              <input id="alipayTestAccountInput" placeholder="æ‰‹æœºå· / é‚®ç®±" />
            </div>
            <div>
              <label>è½¬è´¦æµ‹è¯• - æ”¶æ¬¾å§“å</label>
              <input id="alipayTestNameInput" placeholder="çœŸå®å§“å" />
            </div>
            <div>
              <label>è½¬è´¦æµ‹è¯• - é‡‘é¢(å…ƒ)</label>
              <input id="alipayTestAmountInput" type="number" placeholder="æœ€å° 0.1" />
            </div>
            <div>
              <label>è½¬è´¦åœºæ™¯ä¿¡æ¯ç±»å‹</label>
              <input id="alipaySceneInfoTypeInput" placeholder="å¦‚ï¼šä¸šåŠ¡åœºæ™¯" />
            </div>
            <div>
              <label>è½¬è´¦åœºæ™¯ä¿¡æ¯å†…å®¹</label>
              <input id="alipaySceneInfoContentInput" placeholder="å¦‚ï¼šå¹´ä¼šçº¢åŒ…æç°" />
            </div>
            <div style="display:flex; align-items:flex-end;">
              <button class="btn primary" onclick="transferTest()">å‘èµ·è½¬è´¦æµ‹è¯•</button>
            </div>
          </div>
          <label style="margin-top:10px; display:block;">è½¬è´¦åœºæ™¯ä¸ŠæŠ¥ä¿¡æ¯(JSON æ•°ç»„ï¼Œå¯é€‰ï¼Œä¼˜å…ˆçº§æœ€é«˜)</label>
          <textarea id="alipaySceneReportJson" class="result-box"
            placeholder='å¯é€‰ç¤ºä¾‹ï¼š[{"info_type":"ä¸šåŠ¡åœºæ™¯","info_content":"å¹´ä¼šçº¢åŒ…æç°"}]'></textarea>
          <textarea id="alipayTransferResult" class="result-box" readonly placeholder="è½¬è´¦æµ‹è¯•ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º"></textarea>
        </div>
      </div>
    </section>

    <section class="tab-panel" data-tab-panel="system">
      <div class="grid split" style="margin-top:16px;">
        <div class="card">
          <h2>âš ï¸ æ•°æ®é‡ç½®</h2>
          <div class="note" style="color:#e74c3c; margin-top:8px;">
            <strong>å±é™©æ“ä½œï¼</strong>æ­¤æ“ä½œå°†æ¸…ç©ºæ‰€æœ‰æ•°æ®è¡¨å¹¶é‡ç½®è‡ªå¢IDï¼ŒåŒ…æ‹¬ï¼šç”¨æˆ·ã€è½®æ¬¡ã€è¯„åˆ†ã€é’±åŒ…ã€æç°è®°å½•ç­‰ã€‚æ­¤æ“ä½œä¸å¯æ’¤é”€ï¼
          </div>
          <div class="form-row" style="margin-top:16px;">
            <div>
              <label>åˆå§‹åŒ–å¯†é’¥ (INIT_SECRET)</label>
              <input id="initSecretInput" type="password" placeholder="è¯·è¾“å…¥åˆå§‹åŒ–å¯†é’¥" autocomplete="off" />
            </div>
            <div style="display:flex; align-items:flex-end;">
              <button class="btn" style="background:#e74c3c; color:#fff;" onclick="resetAllData()">ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰æ•°æ®</button>
            </div>
          </div>
          <div id="resetResult" class="note" style="margin-top:12px;"></div>
        </div>
        <div class="card">
          <h2>ç³»ç»Ÿä¿¡æ¯</h2>
          <div class="note" style="margin-top:8px;">ç‰ˆæœ¬ï¼šv1.0.0</div>
          <div class="note">æ•°æ®é‡ç½®åŠŸèƒ½éœ€è¦åœ¨ .env æ–‡ä»¶ä¸­é…ç½® INIT_SECRET æ‰èƒ½ä½¿ç”¨ã€‚</div>
        </div>
      </div>
    </section>
  </div>

  <div id="lockModal" class="modal">
    <div class="card">
      <div style="display:flex; justify-content:space-between; align-items:center;">
        <h2>é”å®šååœ¨çº¿ç”¨æˆ·æ¸…å•</h2>
        <button class="btn ghost" onclick="closeLockModal()">å…³é—­</button>
      </div>
      <div class="note">é”å®šååœ¨çº¿ç”¨æˆ·å¯ä¸€é”®å¯¼å…¥ç™½åå•</div>
      <div class="lock-tools">
        <input id="lockFilterInput" type="text" placeholder="æ‰‹æœºå·/æ˜µç§°/ç”¨æˆ·IDï¼Œç©ºæ ¼åˆ†éš”" oninput="applyLockFilter()" />
        <div class="lock-select">
          <label class="lock-check" style="gap:6px;">
            <input id="lockSelectAll" type="checkbox" onchange="toggleLockSelectAll(this.checked)" />
            <span>å…¨é€‰</span>
          </label>
          <span id="lockFilterHint" class="note">å·²ç­›é€‰ 0/0</span>
        </div>
      </div>
      <div id="lockOnlineUsers" class="list lock-list" style="max-height:280px; overflow:auto; margin-top:12px;"></div>
      <div class="footer-actions">
        <button class="btn secondary" onclick="importAllOnline()">ä¸€é”®å¯¼å…¥ç™½åå•</button>
        <button class="btn" onclick="closeLockModal()">å…³é—­</button>
      </div>
    </div>
  </div>

  <div id="bigScreen" class="big-screen">
    <div class="big-shell">
      <div class="big-header">
        <div>
          <div class="big-title" id="bigTitle">çº¢åŒ…é›¨è¿›è¡Œä¸­</div>
          <div class="big-status" id="bigStatus">ç­‰å¾…å¼€å§‹</div>
        </div>
        <div class="big-actions">
          <button class="btn ghost" onclick="toggleBrowserFullscreen()">è¿›å…¥å…¨å±</button>
          <button class="btn" onclick="closeBigScreen(true)">é€€å‡ºå¤§å±</button>
        </div>
      </div>
      <div class="big-countdown" id="bigCountdown">--</div>
      <div class="big-grid">
        <div class="big-card">
          <h3>å®æ—¶æ’è¡Œèµ›é“</h3>
          <div class="race-track">
            <div id="raceSegments" class="race-segments"></div>
            <div id="raceLanes" class="race-lanes"></div>
          </div>
          <div class="big-meta" id="bigLeaderboardHint">å®æ—¶åˆ·æ–°ä¸­...</div>
        </div>
        <div class="big-card">
          <h3>æœ¬è½®è¿›åº¦</h3>
          <div id="bigRoundSummary" class="list"></div>
          <div id="bigAlgoLogic" class="big-meta" style="margin-top:10px;"></div>
          <div class="big-meta" id="bigRoundHint">ç­‰å¾…è½®æ¬¡å¯åŠ¨</div>
          <div class="big-actions" style="margin-top:14px;">
            <button id="bigDrawBtn" class="btn primary" onclick="drawRound()">å¼€å¥–</button>
            <button id="bigViewBatchesBtn" class="btn ghost" onclick="switchTab('batches')"
              style="display:none;">æŸ¥çœ‹æ‰¹æ¬¡</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // =====================
    // State & Config
    // =====================
    const apiBase = '';
    const tokenKey = 'admin_jwt';
    let currentRoundId = null;
    let currentRoundConfig = null;
    let pollTimer = null;
    let followCurrent = true;
    const qpsSeries = [];
    const scoreSeries = [];
    let onlineUserCache = [];
    let lockFilterText = '';
    const lockSelectedIds = new Set();
    let presetMode = 'preset';
    let withdrawOffset = 0;
    let withdrawLastCount = 0;
    let withdrawTick = 0;
    let leaderboardCache = [];
    let leaderboardLimit = 10;
    let roundStatusCache = '';
    let lastDifficultyKey = 'medium';
    let bigScreenDismissed = false;
    let flowAction = null;
    let flowSecondary = null;
    let liveRoundId = null;
    let liveRoundConfig = null;
    let liveRoundStatus = '';
    let liveLeaderboardCache = [];
    let liveLeaderboardLimit = 10;
    let liveScoreUsers = 0;
    let lastNonEmptyLiveLeaderboard = [];
    let lastLiveMetrics = null;
    let leaderboardTimer = null;
    let leaderboardLock = false;
    let pollLock = false;
    let onlineUsersLock = false;
    let withdrawsLock = false;
    let raceLaneMap = new Map();
    let raceSegmentCount = 10;
    let lastSummaryKey = '';
    let roundResultOffset = 0;
    let roundResultLimit = 50;
    let roundResultTotal = 0;

    const difficultyPresets = {
      // =====================================================
      // ä¸“ä¸šæ¸¸æˆè®¾è®¡å‚æ•° v2 - é‡æ–°å¹³è¡¡
      // =====================================================
      // ã€å…³é”®å‘ç°ã€‘é€Ÿåº¦ç”± drop_visible_ms å†³å®šï¼Œä¸æ˜¯ max_speed
      // drop_visible_ms è¶Šå° = ä¸‹è½è¶Šå¿« = ååº”æ—¶é—´è¶ŠçŸ­
      // max_speed åªæ˜¯é€Ÿåº¦ä¸Šé™ï¼Œä¸»è¦å½±å“æ¸¸æˆåæœŸåŠ é€Ÿ
      // =====================================================

      easy: {
        label: 'ğŸŒŸ ä¼‘é—²æ¨¡å¼',
        // è®¾è®¡ç›®æ ‡ï¼šè¶…çº§è½»æ¾ï¼Œäººäººèƒ½ç©ï¼Œå…¨å‘˜æ™®æƒ 
        slice_ms: 1600,          // æ¯1.6ç§’ä¸€æ‰¹ â†’ éå¸¸ä»å®¹çš„èŠ‚å¥
        drop_visible_ms: 4500,   // 4.5ç§’å¯è§ï¼â†’ è¶…æ…¢é€Ÿä¸‹è½ï¼Œå……è¶³ååº”æ—¶é—´
        drops_per_slice: 3,      // æ¯æ‰¹ä»…3ä¸ª â†’ å±å¹•ç¨€ç–ï¼Œä¸æ‹¥æŒ¤
        bombs_per_slice: 0,      // æ˜¾å¼è®¾ä¸º0 â†’ æ— ç‚¸å¼¹ï¼ˆå·²ä¿®å¤åç«¯ï¼‰
        bigs_per_slice: 1,       // æ¯æ‰¹1ä¸ªå¤§çº¢åŒ…
        empty_per_slice: 0,      // æ— ç©ºåŒ…
        score_total: 500,        // æ¯åˆ‡ç‰‡500åˆ†
        bomb_penalty: 0,         // æ˜¾å¼è®¾ä¸º0 â†’ æ— æƒ©ç½šï¼ˆå·²ä¿®å¤åç«¯ï¼‰
        big_multiplier: 1.5,     // å¤§çº¢åŒ…1.5å€
        max_speed: 0.5           // ä½é€Ÿä¸Šé™
        // ä½“éªŒï¼šæ‚ é—²æ¼«æ­¥æ‘˜çº¢åŒ…
      },

      medium: {
        label: 'â­ æ ‡å‡†æ¨¡å¼',
        // è®¾è®¡ç›®æ ‡ï¼šé€‚åº¦æŒ‘æˆ˜ï¼Œå¤§ä¼—å¨±ä¹é¦–é€‰
        slice_ms: 1200,          // æ¯1.2ç§’ä¸€æ‰¹ â†’ è½»å¿«èŠ‚å¥
        drop_visible_ms: 3000,   // 3ç§’å¯è§ â†’ æ­£å¸¸ååº”é€Ÿåº¦
        drops_per_slice: 5,      // æ¯æ‰¹5ä¸ª â†’ é€‚ä¸­å¯†åº¦
        bombs_per_slice: 1,      // æ¯æ‰¹1ä¸ªç‚¸å¼¹ â†’ 20%æ¦‚ç‡
        bigs_per_slice: 1,       // æ¯æ‰¹1ä¸ªå¤§çº¢åŒ…
        empty_per_slice: 0,      // æ— ç©ºåŒ…
        score_total: 700,        // æ¯åˆ‡ç‰‡700åˆ†
        bomb_penalty: 25,        // ç‚¸å¼¹æ‰£25åˆ† â†’ è½»åº¦æƒ©ç½š
        big_multiplier: 1.8,     // å¤§çº¢åŒ…1.8å€
        max_speed: 0.8           // ä¸­ç­‰é€Ÿåº¦ä¸Šé™
        // ä½“éªŒï¼šæœ‰èŠ‚å¥æ„Ÿï¼Œç¨éœ€æ³¨æ„ç‚¸å¼¹
      },

      hard: {
        label: 'ğŸ”¥ æŒ‘æˆ˜æ¨¡å¼',
        // è®¾è®¡ç›®æ ‡ï¼šå¿«èŠ‚å¥é«˜å¼ºåº¦
        slice_ms: 900,           // æ¯0.9ç§’ä¸€æ‰¹ â†’ å¯†é›†èŠ‚å¥
        drop_visible_ms: 2200,   // 2.2ç§’å¯è§ â†’ è¾ƒå¿«ä¸‹è½
        drops_per_slice: 6,      // æ¯æ‰¹6ä¸ª â†’ é«˜å¯†åº¦
        bombs_per_slice: 1,      // æ¯æ‰¹1ä¸ªç‚¸å¼¹
        bigs_per_slice: 1,       // æ¯æ‰¹1ä¸ªå¤§çº¢åŒ…
        empty_per_slice: 1,      // æ¯æ‰¹1ä¸ªç©ºåŒ…å¹²æ‰°
        score_total: 900,        // æ¯åˆ‡ç‰‡900åˆ†
        bomb_penalty: 60,        // ç‚¸å¼¹æ‰£60åˆ† â†’ ä¸­åº¦æƒ©ç½š
        big_multiplier: 2.0,     // å¤§çº¢åŒ…2å€
        max_speed: 1.0           // é«˜é€Ÿä¸Šé™
        // ä½“éªŒï¼šæ‰‹å¿™è„šä¹±ä½†åˆºæ¿€
      },

      hell: {
        label: 'ğŸ’€ åœ°ç‹±æ¨¡å¼',
        // è®¾è®¡ç›®æ ‡ï¼šæé™æŒ‘æˆ˜ï¼Œåªç»™é«˜æ‰‹
        slice_ms: 700,           // æ¯0.7ç§’ä¸€æ‰¹ â†’ æé«˜å¯†åº¦
        drop_visible_ms: 1600,   // 1.6ç§’å¯è§ â†’ é£é€Ÿä¸‹è½ï¼
        drops_per_slice: 7,      // æ¯æ‰¹7ä¸ª
        bombs_per_slice: 2,      // æ¯æ‰¹2ä¸ªç‚¸å¼¹ â†’ 29%æ¦‚ç‡
        bigs_per_slice: 1,       // æ¯æ‰¹1ä¸ªå¤§çº¢åŒ…
        empty_per_slice: 1,      // æ¯æ‰¹1ä¸ªç©ºåŒ…
        score_total: 1100,       // æ¯åˆ‡ç‰‡1100åˆ†
        bomb_penalty: 100,       // ç‚¸å¼¹æ‰£100åˆ† â†’ é‡åº¦æƒ©ç½šï¼
        big_multiplier: 2.5,     // å¤§çº¢åŒ…2.5å€ â†’ é«˜é£é™©é«˜å›æŠ¥
        max_speed: 1.2           // æœ€é«˜é€Ÿåº¦
        // ä½“éªŒï¼šåªæœ‰æœ€å¼ºè€…æ‰èƒ½ç”Ÿå­˜
      },

      party: {
        label: 'ğŸ‰ æ´¾å¯¹æ¨¡å¼',
        // è®¾è®¡ç›®æ ‡ï¼šè§†è§‰éœ‡æ’¼ï¼Œæ¬¢ä¹æ°›å›´
        slice_ms: 600,           // æ¯0.6ç§’ä¸€æ‰¹ â†’ çº¢åŒ…é›¨æš´é£ï¼
        drop_visible_ms: 3200,   // 3.2ç§’å¯è§ â†’ è™½å¤šä½†ä¸å¤ªå¿«
        drops_per_slice: 10,     // æ¯æ‰¹10ä¸ªï¼â†’ æ»¡å±çº¢åŒ…
        bombs_per_slice: 0,      // æ— ç‚¸å¼¹ â†’ å°½æƒ…ç‚¹ï¼
        bigs_per_slice: 3,       // æ¯æ‰¹3ä¸ªå¤§çº¢åŒ… â†’ æƒŠå–œè¿è¿
        empty_per_slice: 0,      // æ— ç©ºåŒ…
        score_total: 400,        // æ¯åˆ‡ç‰‡400åˆ†ï¼ˆå•ä¸ªåˆ†å€¼ä½ä½†æ•°é‡å¤šï¼‰
        bomb_penalty: 0,         // æ— æƒ©ç½š
        big_multiplier: 2.0,     // å¤§çº¢åŒ…2å€
        max_speed: 0.9           // é€‚ä¸­é€Ÿåº¦
        // ä½“éªŒï¼šå¹´ä¼šæ°›å›´æ‹…å½“ï¼Œæ»¡å±é‡‘å…‰
      }
    };

    const roundStatusLabels = {
      WAITING: 'å¾…å¼€å§‹',
      LOCKED: 'å·²é”å®š',
      COUNTDOWN: 'å€’è®¡æ—¶',
      RUNNING: 'è¿›è¡Œä¸­',
      READY_DRAW: 'å¾…å¼€å¥–',
      DRAWING: 'å¼€å¥–ä¸­',
      PENDING_CONFIRM: 'å¾…ç¡®è®¤å…¥è´¦',
      FINISHED: 'å·²ç»“æŸ'
    };

    const batchStatusLabels = {
      PENDING_CONFIRM: 'å¾…ç¡®è®¤å…¥è´¦',
      CONFIRMED: 'å·²ç¡®è®¤å…¥è´¦',
      READY_DRAW: 'å¾…å¼€å¥–',
      DRAWING: 'å¼€å¥–ä¸­',
      VOID: 'å·²ä½œåºŸ'
    };

    // =====================
    // Helpers
    // =====================
    function getToken() {
      return sessionStorage.getItem(tokenKey) || '';
    }

    function setToken(token) {
      sessionStorage.setItem(tokenKey, token);
    }

    function adminHeaders() {
      return {
        'Content-Type': 'application/json',
        'Authorization': 'Bearer ' + getToken()
      };
    }

    function setConnStatus(text, ok = true) {
      const el = document.getElementById('connStatus');
      if (!el) return;
      el.innerText = text;
      el.className = ok ? 'chip ok' : 'chip warn';
    }

    function toggleFollow() {
      setFollowCurrent(!followCurrent);
    }

    function setFollowCurrent(val) {
      followCurrent = !!val;
      const btn = document.getElementById('followBtn');
      if (btn) btn.innerText = followCurrent ? 'è·Ÿéšå½“å‰' : 'å·²æš‚åœè·Ÿéš';
    }

    function yuanToFen(val) {
      const num = parseFloat(val || '0');
      return Math.round(num * 100);
    }

    function maskPhone(phone) {
      if (!phone || phone.length < 7) return phone || '';
      return phone.slice(0, 3) + '****' + phone.slice(-4);
    }

    function maskKeep(val, head, tail) {
      const raw = String(val || '');
      if (!raw) return '';
      if (raw.length <= head + tail) return raw;
      return raw.slice(0, head) + '*'.repeat(raw.length - head - tail) + raw.slice(-tail);
    }

    function escapeHTML(str) {
      return String(str || '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function formatTime(val) {
      if (!val) return '--';
      const d = new Date(val);
      if (Number.isNaN(d.getTime())) return '--';
      const pad = (n) => String(n).padStart(2, '0');
      return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())} ${pad(d.getHours())}:${pad(d.getMinutes())}`;
    }

    async function readJsonSafe(res) {
      const text = await res.text();
      if (!text) return {};
      try {
        return JSON.parse(text);
      } catch (_) {
        return { raw: text };
      }
    }

    async function requireOk(res, fallbackMsg) {
      const data = await readJsonSafe(res);
      if (!res.ok || data.error) {
        throw new Error(data.error || data.raw || fallbackMsg || 'è¯·æ±‚å¤±è´¥');
      }
      return data;
    }

    function pushSeries(arr, value) {
      arr.push(value);
      if (arr.length > 30) arr.shift();
    }

    function roundStatusLabel(status) {
      return roundStatusLabels[status] || status || '--';
    }

    function roundStatusClass(status) {
      if (status === 'RUNNING' || status === 'FINISHED') return 'ok';
      if (['WAITING', 'LOCKED', 'COUNTDOWN', 'READY_DRAW', 'DRAWING', 'PENDING_CONFIRM'].includes(status)) return 'warn';
      return '';
    }

    function batchStatusLabel(status) {
      return batchStatusLabels[status] || status || '--';
    }

    function batchStatusClass(status) {
      if (status === 'CONFIRMED') return 'ok';
      if (['PENDING_CONFIRM', 'READY_DRAW', 'DRAWING'].includes(status)) return 'warn';
      return '';
    }

    function avatarHue(id) {
      const num = parseInt(id || '0', 10);
      return Math.abs(num * 37) % 360;
    }

    function renderAvatar(item, sizeClass = '') {
      const url = item.avatar_url || item.avatar || '';
      const nickname = item.nickname || '';
      const uid = item.user_id || item.id || 0;
      const fallback = nickname ? nickname.slice(0, 1) : String(uid || 'U').slice(-1);
      if (url) {
        return `<img class="avatar ${sizeClass}" src="${escapeHTML(url)}" alt="${escapeHTML(nickname || 'ç”¨æˆ·')}" />`;
      }
      const hue = avatarHue(uid);
      return `<div class="avatar ${sizeClass} fallback" style="--avatar-hue:${hue};">${escapeHTML(fallback)}</div>`;
    }

    function renderUserName(item) {
      const nickname = item.nickname ? escapeHTML(item.nickname) : '';
      const userId = item.user_id || item.id || '';
      const phone = item.phone ? maskPhone(item.phone) : '';
      const parts = [];
      if (nickname) parts.push(nickname);
      if (userId) parts.push(`ç”¨æˆ·${userId}`);
      if (phone) parts.push(phone);
      return parts.join(' Â· ') || '--';
    }

    function renderRaceName(item) {
      if (item.nickname) return escapeHTML(item.nickname);
      if (item.phone) return maskPhone(item.phone);
      const uid = item.user_id || item.id || '';
      return uid ? `ç”¨æˆ·${uid}` : '--';
    }

    function switchTab(tab) {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tab);
      });
      document.querySelectorAll('[data-tab-panel]').forEach(panel => {
        panel.classList.toggle('active', panel.dataset.tabPanel === tab);
      });
    }

    function initTabs() {
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.addEventListener('click', () => switchTab(btn.dataset.tab));
      });
    }

    function handleFlowAction() {
      if (typeof flowAction === 'function') {
        flowAction();
      }
    }

    function handleFlowSecondary() {
      if (typeof flowSecondary === 'function') {
        flowSecondary();
      }
    }

    function updateFlowHint(round) {
      const status = round?.status || '';
      const statusLabel = roundStatusLabel(status);
      const statusTag = document.getElementById('flowStatusTag');
      const statusText = document.getElementById('flowStatusText');
      const hintEl = document.getElementById('flowHint');
      const actionBtn = document.getElementById('flowActionBtn');
      const secondaryBtn = document.getElementById('flowSecondaryBtn');
      if (statusTag) {
        statusTag.innerText = statusLabel;
        statusTag.className = `status-tag ${roundStatusClass(status)}`;
      }
      if (statusText) {
        statusText.innerText = `å½“å‰é˜¶æ®µï¼š${statusLabel}`;
      }

      let hint = 'ç­‰å¾…è½®æ¬¡ä¿¡æ¯...';
      flowAction = null;
      flowSecondary = null;
      if (!round || !round.id) {
        hint = 'è¯·å…ˆåˆ›å»ºè½®æ¬¡å¹¶å®Œæˆå‚æ•°ç¡®è®¤ã€‚';
        flowAction = () => {
          switchTab('rounds');
          document.getElementById('createRoundCard')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
        if (actionBtn) actionBtn.innerText = 'å»åˆ›å»º';
      } else if (status === 'WAITING') {
        hint = 'è½®æ¬¡å·²åˆ›å»ºï¼Œå»ºè®®å…ˆé”å®šåœ¨çº¿ç”¨æˆ·å¹¶ç¡®è®¤ç™½åå•ã€‚';
        flowAction = () => lockRound();
        if (actionBtn) actionBtn.innerText = 'é”å®šè½®æ¬¡';
      } else if (status === 'LOCKED') {
        hint = 'é”å®šå®Œæˆï¼Œå¯ä»¥å¼€å§‹å€’è®¡æ—¶å¹¶è¿›å…¥çº¢åŒ…é›¨ã€‚';
        flowAction = () => startRound();
        if (actionBtn) actionBtn.innerText = 'å¼€å§‹å€’è®¡æ—¶';
      } else if (status === 'COUNTDOWN') {
        hint = 'å€’è®¡æ—¶è¿›è¡Œä¸­ï¼Œè¯·å…³æ³¨å¤§å±å±•ç¤ºã€‚';
        if (actionBtn) actionBtn.innerText = 'è¿›è¡Œä¸­';
      } else if (status === 'RUNNING') {
        hint = 'çº¢åŒ…é›¨æ­£åœ¨è¿›è¡Œï¼Œå®æ—¶æ’è¡Œå·²åŒæ­¥åˆ°å¤§å±ã€‚';
        if (actionBtn) actionBtn.innerText = 'è¿›è¡Œä¸­';
      } else if (status === 'READY_DRAW') {
        hint = 'æ¸¸æˆå·²ç»“æŸï¼Œå¯ä»¥ç«‹å³å¼€å¥–ç”Ÿæˆæ‰¹æ¬¡ã€‚';
        flowAction = () => drawRound();
        if (actionBtn) actionBtn.innerText = 'å¼€å¥–';
      } else if (status === 'DRAWING') {
        hint = 'å¼€å¥–è®¡ç®—ä¸­ï¼Œè¯·ç¨å€™ã€‚';
        if (actionBtn) actionBtn.innerText = 'è®¡ç®—ä¸­';
      } else if (status === 'PENDING_CONFIRM') {
        hint = 'æ‰¹æ¬¡å¾…ç¡®è®¤å…¥è´¦ï¼Œè¯·å‰å¾€æ‰¹æ¬¡åˆ—è¡¨å®Œæˆç¡®è®¤ã€‚';
        flowAction = () => switchTab('batches');
        flowSecondary = () => openBigScreen(true);
        if (actionBtn) actionBtn.innerText = 'æŸ¥çœ‹æ‰¹æ¬¡';
        if (secondaryBtn) {
          secondaryBtn.style.display = 'inline-flex';
          secondaryBtn.innerText = 'å¤§å±å›æ”¾';
        }
      } else if (status === 'FINISHED') {
        hint = 'æœ¬è½®å·²å®Œæˆï¼Œå¯å‡†å¤‡ä¸‹ä¸€è½®é…ç½®ã€‚';
        flowAction = () => {
          switchTab('rounds');
          document.getElementById('createRoundCard')?.scrollIntoView({ behavior: 'smooth', block: 'start' });
        };
        if (actionBtn) actionBtn.innerText = 'åˆ›å»ºæ–°è½®æ¬¡';
      }

      if (hintEl) hintEl.innerText = hint;
      if (actionBtn) {
        actionBtn.disabled = !flowAction;
        if (!flowAction && !['COUNTDOWN', 'RUNNING', 'DRAWING'].includes(status)) {
          actionBtn.disabled = true;
        }
      }
      if (secondaryBtn && status !== 'PENDING_CONFIRM') {
        secondaryBtn.style.display = 'none';
      }
    }

    function openBigScreen(manual = false) {
      const overlay = document.getElementById('bigScreen');
      if (!overlay) return;
      if (manual) {
        bigScreenDismissed = false;
      }
      overlay.classList.add('active');
      document.body.classList.add('big-open');
      if (lastLiveMetrics) {
        updateBigScreen(lastLiveMetrics, { noToggle: true });
      }
    }

    function closeBigScreen(manual = false) {
      const overlay = document.getElementById('bigScreen');
      if (!overlay) return;
      if (manual) {
        bigScreenDismissed = true;
      }
      overlay.classList.remove('active');
      document.body.classList.remove('big-open');
    }

    function toggleBrowserFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(() => { });
      } else {
        document.exitFullscreen().catch(() => { });
      }
    }

    function renderRaceSegments(count) {
      const segEl = document.getElementById('raceSegments');
      if (!segEl) return;
      segEl.innerHTML = '';
      if (count <= 1) return;
      for (let i = 1; i < count; i += 1) {
        const line = document.createElement('div');
        line.className = 'race-segment-line';
        const left = (i / count) * 100;
        line.style.left = `${left}%`;
        const label = document.createElement('div');
        label.className = 'race-segment-label';
        label.style.left = `${left}%`;
        label.innerText = `${i}/${count}`;
        segEl.appendChild(line);
        segEl.appendChild(label);
      }
    }

    function renderBigLeaderboard(items, status) {
      const lanesEl = document.getElementById('raceLanes');
      const hint = document.getElementById('bigLeaderboardHint');
      if (!lanesEl) return;
      const trackEl = lanesEl.closest('.race-track');
      if (!items || items.length === 0) {
        lanesEl.innerHTML = '<div class="note">æš‚æ— æ’è¡Œæ•°æ®</div>';
        raceLaneMap = new Map();
        if (trackEl) {
          trackEl.classList.remove('compact');
          trackEl.classList.remove('dense');
        }
        lanesEl.classList.remove('cols-2', 'cols-3');
        lanesEl.style.gridTemplateColumns = '';
        if (hint) hint.innerText = 'ç­‰å¾…ç©å®¶å‚ä¸...';
        return;
      }
      const isFinal = ['READY_DRAW', 'DRAWING', 'PENDING_CONFIRM', 'FINISHED'].includes(status);
      const segmentCount = liveRoundConfig?.rank_segments || 10;
      if (segmentCount !== raceSegmentCount) {
        raceSegmentCount = segmentCount;
        renderRaceSegments(segmentCount);
      }
      const maxScore = items[0]?.score || 1;
      const currentIDs = new Set();
      const lanes = [];
      const total = items.length;
      if (trackEl) {
        trackEl.classList.toggle('compact', total > 30);
        trackEl.classList.toggle('dense', total > 60);
      }
      const useCols = total > 40 ? (total > 100 ? 3 : 2) : 1;
      lanesEl.classList.toggle('cols-2', useCols === 2);
      lanesEl.classList.toggle('cols-3', useCols === 3);
      if (useCols === 1) {
        lanesEl.style.gridTemplateColumns = '';
      }
      items.forEach((item, idx) => {
        currentIDs.add(item.user_id);
        let lane = raceLaneMap.get(item.user_id);
        if (!lane) {
          lane = document.createElement('div');
          lane.className = 'race-lane';
          const car = document.createElement('div');
          car.className = 'race-car';
          lane.appendChild(car);
          raceLaneMap.set(item.user_id, lane);
        }
        lane.dataset.score = String(item.score || 0);
        const car = lane.querySelector('.race-car');
        if (car) {
          car.innerHTML = `
            <span class="race-rank">#${idx + 1}</span>
            ${renderAvatar(item, 'mini')}
            <span class="race-name">${renderRaceName(item)}</span>
            <span class="race-score">${item.score}</span>
          `;
        }
        lane.dataset.rank = String(idx + 1);
        lanes.push(lane);
      });
      for (const [uid, lane] of raceLaneMap.entries()) {
        if (!currentIDs.has(uid)) {
          lane.remove();
          raceLaneMap.delete(uid);
        }
      }
      lanesEl.innerHTML = '';
      lanes.forEach((lane) => lanesEl.appendChild(lane));
      lanes.forEach((lane) => {
        const car = lane.querySelector('.race-car');
        if (!car) return;
        const scoreVal = parseFloat(lane.dataset.score || '0');
        const laneWidth = lane.clientWidth || lanesEl.clientWidth;
        const trackWidth = Math.max(120, laneWidth - 120);
        const progress = maxScore > 0 ? scoreVal / maxScore : 0;
        const x = Math.max(0, Math.min(trackWidth, progress * trackWidth));
        car.style.transform = `translate(${x}px, -50%)`;
      });
      if (hint) {
        if (isFinal) {
          hint.innerText = 'å·²ç»“æŸï¼Œæ˜¾ç¤ºæœ¬è½®æ’è¡Œ';
        } else {
          hint.innerText = 'å®æ—¶åˆ·æ–°ä¸­...';
        }
      }
    }

    function leaderboardChanged(prevList, nextList) {
      if (!prevList || !nextList) return true;
      if (prevList.length !== nextList.length) return true;
      for (let i = 0; i < nextList.length; i += 1) {
        const prev = prevList[i];
        const next = nextList[i];
        if (!prev || !next) return true;
        if (prev.user_id !== next.user_id || prev.score !== next.score) return true;
      }
      return false;
    }

    function renderBigRoundSummary(round, scoreSum, scoreUsers) {
      const el = document.getElementById('bigRoundSummary');
      if (!el) return;
      if (!round) {
        el.innerHTML = '<div class="note">æš‚æ— è½®æ¬¡</div>';
        return;
      }
      const sumText = typeof scoreSum === 'number' ? scoreSum : '--';
      const userText = typeof scoreUsers === 'number' ? scoreUsers : '--';
      el.innerHTML = `
        <div class="list-item"><span>è½®æ¬¡</span><span>#${round.id}</span></div>
        <div class="list-item"><span>æ ‡é¢˜</span><span>${escapeHTML(round.title || 'çº¢åŒ…é›¨')}</span></div>
        <div class="list-item"><span>å¥–æ± </span><span>${(round.total_pool / 100).toFixed(2)} å…ƒ</span></div>
        <div class="list-item"><span>çŠ¶æ€</span><span>${roundStatusLabel(round.status)}</span></div>
        <div class="list-item"><span>æ—¶é•¿</span><span>${round.duration_sec}s</span></div>
        <div class="list-item"><span>ç´¯è®¡åˆ†å€¼</span><span>${sumText}</span></div>
        <div class="list-item"><span>å‚ä¸äººæ•°</span><span>${userText}</span></div>
      `;
    }

    function renderAlgoLogic(round) {
      const el = document.getElementById('bigAlgoLogic');
      if (!el) return;
      if (!round) {
        el.innerText = '';
        return;
      }
      const lucky = round.lucky_ratio || 0;
      const base = round.base_ratio || 0;
      const tail = round.tail_top_n || 0;
      const segments = round.rank_segments || 10;
      el.innerText = `å¼€å¥–ç®—æ³•ï¼šå¥–æ± åˆ†ä¸º å¹¸è¿æ± ${lucky}% + åŸºç¡€æ± ${base}%ï¼ŒåŸºç¡€åˆ†é…æƒé‡=åˆ†å€¼^1.4ï¼Œå¹¸è¿æ± éšæœºæŠ½å¥–(æƒé‡åŒä¸Š)ï¼Œå°¾å·®è¡¥ç»™å‰${tail}åï¼›æ’è¡Œåˆ†æ®µ ${segments}ã€‚`;
    }

    function updateBigScreen(data, opts = {}) {
      const round = data.round || null;
      const status = round?.status || '';
      if (!opts.noToggle) {
        if (['WAITING', 'LOCKED', 'FINISHED', ''].includes(status)) {
          bigScreenDismissed = false;
        }
        const shouldShow = ['COUNTDOWN', 'RUNNING', 'READY_DRAW', 'DRAWING', 'PENDING_CONFIRM'].includes(status);
        if (shouldShow && !bigScreenDismissed) {
          openBigScreen(false);
        }
        if (!shouldShow) {
          closeBigScreen(false);
        }
      }
      const titleEl = document.getElementById('bigTitle');
      const statusEl = document.getElementById('bigStatus');
      const countdownEl = document.getElementById('bigCountdown');
      const hintEl = document.getElementById('bigRoundHint');
      const drawBtn = document.getElementById('bigDrawBtn');
      const viewBatchesBtn = document.getElementById('bigViewBatchesBtn');
      const now = data.server_time || Date.now();
      if (titleEl) titleEl.innerText = round?.title || 'çº¢åŒ…é›¨è¿›è¡Œä¸­';
      if (statusEl) statusEl.innerText = `çŠ¶æ€ï¼š${roundStatusLabel(status)}`;
      if (countdownEl) {
        if (status === 'COUNTDOWN' && round?.start_at) {
          const remain = Math.max(0, Math.ceil((round.start_at - now) / 1000));
          countdownEl.innerText = `${remain}s`;
        } else if (status === 'RUNNING' && round?.end_at) {
          const remain = Math.max(0, Math.ceil((round.end_at - now) / 1000));
          countdownEl.innerText = `${remain}s`;
        } else if (['READY_DRAW', 'DRAWING', 'PENDING_CONFIRM', 'FINISHED'].includes(status)) {
          countdownEl.innerText = 'å·²ç»“æŸ';
        } else {
          countdownEl.innerText = '--';
        }
      }
      if (hintEl) {
        if (status === 'READY_DRAW') {
          hintEl.innerText = 'æœ¬è½®å·²ç»“æŸï¼Œç­‰å¾…å¼€å¥–ã€‚';
        } else if (status === 'PENDING_CONFIRM') {
          hintEl.innerText = 'å¼€å¥–å·²å®Œæˆï¼Œç­‰å¾…ç¡®è®¤å…¥è´¦ã€‚';
        } else if (status === 'RUNNING') {
          hintEl.innerText = 'çº¢åŒ…é›¨è¿›è¡Œä¸­ï¼Œå®æ—¶æ’è¡Œå·²åŒæ­¥ã€‚';
        } else {
          hintEl.innerText = 'ç­‰å¾…è½®æ¬¡å¯åŠ¨';
        }
      }
      if (drawBtn) {
        drawBtn.style.display = status === 'READY_DRAW' ? 'inline-flex' : 'none';
      }
      if (viewBatchesBtn) {
        viewBatchesBtn.style.display = status === 'PENDING_CONFIRM' ? 'inline-flex' : 'none';
      }
      const summaryKey = round ? [
        round.id,
        round.status,
        round.lucky_ratio,
        round.base_ratio,
        round.tail_top_n,
        round.rank_segments,
        data.score_sum,
        data.score_users
      ].join('|') : '';
      if (summaryKey !== lastSummaryKey) {
        renderBigRoundSummary(round, data.score_sum, data.score_users);
        renderAlgoLogic(round);
        lastSummaryKey = summaryKey;
      }
      renderBigLeaderboard(liveLeaderboardCache, status);
    }

    // =====================
    // Preset Logic
    // =====================
    function getPreset() {
      const key = document.getElementById('difficultySelect')?.value || 'medium';
      return difficultyPresets[key] || difficultyPresets.medium;
    }

    function refreshDifficultyHint() {
      const preset = getPreset();
      const el = document.getElementById('difficultyHint');
      if (!el || !preset) return;
      el.innerText = `${preset.label}ï¼šæ˜¾ç¤º${preset.drop_visible_ms}ms / æ¯ç‰‡${preset.drops_per_slice}çº¢åŒ… / ç‚¸å¼¹${preset.bombs_per_slice} / å¤§çº¢åŒ…${preset.bigs_per_slice} / ç©ºåŒ…${preset.empty_per_slice} / å¹¸è¿åˆ†${preset.score_total} / é€Ÿåº¦ä¸Šé™${preset.max_speed}`;
    }

    function updateRatioHint() {
      const lucky = parseInt(document.getElementById('luckyRatioInput')?.value || '0', 10) || 0;
      const base = parseInt(document.getElementById('baseRatioInput')?.value || '0', 10) || 0;
      const hint = document.getElementById('ratioHint');
      if (!hint) return;
      const rest = Math.max(0, 100 - lucky - base);
      hint.innerText = `å½“å‰åˆ†é…ï¼šå¹¸è¿æ±  ${lucky}% + åŸºç¡€æ±  ${base}%ï¼ˆå‰©ä½™ ${rest}% ç”¨äºè¡¥å·®ï¼‰`;
    }

    function updatePresetStatus() {
      const el = document.getElementById('presetStatus');
      const preset = getPreset();
      if (!el || !preset) return;
      if (presetMode === 'custom') {
        el.innerText = 'å½“å‰ï¼šè‡ªå®šä¹‰';
        return;
      }
      if (presetMode === 'pending') {
        el.innerText = `å·²é€‰æ‹©${preset.label}ï¼ˆæœªåº”ç”¨ï¼‰`;
        return;
      }
      el.innerText = `å½“å‰ï¼šé¢„è®¾Â·${preset.label}`;
    }

    function applyPreset() {
      const preset = getPreset();
      if (!preset) return;
      const setVal = (id, value) => {
        const input = document.getElementById(id);
        if (!input) return;
        input.value = String(value);
      };
      setVal('sliceMsInput', preset.slice_ms);
      setVal('dropVisibleMsInput', preset.drop_visible_ms);
      setVal('dropsPerSecInput', '');
      setVal('dropsPerSliceInput', preset.drops_per_slice);
      setVal('bombsPerSliceInput', preset.bombs_per_slice);
      setVal('bigsPerSliceInput', preset.bigs_per_slice);
      setVal('emptyPerSliceInput', preset.empty_per_slice);
      setVal('scoreTotalInput', preset.score_total);
      setVal('bombPenaltyInput', preset.bomb_penalty);
      setVal('bigMultiplierInput', preset.big_multiplier);
      setVal('maxSpeedInput', preset.max_speed);
      presetMode = 'preset';
      lastDifficultyKey = document.getElementById('difficultySelect')?.value || lastDifficultyKey;
      updatePresetStatus();
    }

    function markCustom() {
      if (presetMode === 'custom') return;
      presetMode = 'custom';
      updatePresetStatus();
    }

    document.getElementById('difficultySelect')?.addEventListener('change', () => {
      refreshDifficultyHint();
      const select = document.getElementById('difficultySelect');
      if (!select) return;
      if (presetMode === 'custom') {
        const ok = confirm('å½“å‰å‚æ•°å·²è¢«æ‰‹åŠ¨ä¿®æ”¹ï¼Œåˆ‡æ¢éš¾åº¦ä¼šè¦†ç›–è‡ªå®šä¹‰é…ç½®ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ');
        if (!ok) {
          select.value = lastDifficultyKey;
          refreshDifficultyHint();
          updatePresetStatus();
          return;
        }
      }
      applyPreset();
    });

    document.getElementById('applyPresetBtn')?.addEventListener('click', () => {
      applyPreset();
    });

    [
      'title',
      'totalPool',
      'luckyRatioInput',
      'baseRatioInput',
      'duration',
      'countdownInput',
      'dropVisibleMsInput',
      'dropsPerSecInput',
      'sliceMsInput',
      'dropsPerSliceInput',
      'bombsPerSliceInput',
      'bigsPerSliceInput',
      'emptyPerSliceInput',
      'scoreTotalInput',
      'bombPenaltyInput',
      'bigMultiplierInput',
      'maxSpeedInput',
      'minAwardInput',
      'maxAwardInput',
      'tailTopNInput',
      'rankSegmentsInput'
    ].forEach((id) => {
      const el = document.getElementById(id);
      if (!el) return;
      el.addEventListener('input', markCustom);
      el.addEventListener('change', markCustom);
    });

    // =====================
    // Auth
    // =====================
    async function adminLogin() {
      const password = document.getElementById('adminPassword').value.trim();
      if (!password) return;
      const res = await fetch(`${apiBase}/api/admin/login`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ password })
      });
      const data = await res.json();
      if (data.token) {
        setToken(data.token);
        document.getElementById('loginTip').innerText = 'ç™»å½•æˆåŠŸ';
        setConnStatus('å·²ç™»å½•');
        startPolling();
      } else {
        document.getElementById('loginTip').innerText = data.error || 'ç™»å½•å¤±è´¥';
        setConnStatus('ç™»å½•å¤±è´¥', false);
      }
    }

    // =====================
    // Round Actions
    // =====================
    async function createRound() {
      const numOrZero = (id) => {
        const el = document.getElementById(id);
        if (!el) return 0;
        const raw = (el.value || '').trim();
        if (!raw) return 0;
        const parsed = parseInt(raw, 10);
        return Number.isFinite(parsed) ? parsed : 0;
      };
      const sliceMsInput = numOrZero('sliceMsInput');
      const dropsPerSec = numOrZero('dropsPerSecInput');
      let dropsPerSlice = numOrZero('dropsPerSliceInput');
      if (dropsPerSec > 0) {
        const sliceMs = sliceMsInput > 0 ? sliceMsInput : 1000;
        dropsPerSlice = Math.max(1, Math.round((dropsPerSec * sliceMs) / 1000));
      }
      let bombsPerSlice = numOrZero('bombsPerSliceInput');
      let bigsPerSlice = numOrZero('bigsPerSliceInput');
      let emptyPerSlice = numOrZero('emptyPerSliceInput');
      const dropCount = Math.max(0, dropsPerSlice);
      if (dropCount > 0 && bombsPerSlice >= dropCount) {
        bombsPerSlice = Math.max(0, dropCount - 1);
      }
      const maxNonBomb = Math.max(0, dropCount - bombsPerSlice);
      if (bigsPerSlice > maxNonBomb) {
        bigsPerSlice = maxNonBomb;
      }
      if (emptyPerSlice > maxNonBomb - bigsPerSlice) {
        emptyPerSlice = Math.max(0, maxNonBomb - bigsPerSlice);
      }
      const bombsInput = document.getElementById('bombsPerSliceInput');
      if (bombsInput && bombsInput.value && bombsPerSlice !== numOrZero('bombsPerSliceInput')) {
        bombsInput.value = String(bombsPerSlice);
      }
      const bigsInput = document.getElementById('bigsPerSliceInput');
      if (bigsInput && bigsInput.value && bigsPerSlice !== numOrZero('bigsPerSliceInput')) {
        bigsInput.value = String(bigsPerSlice);
      }
      const emptyInput = document.getElementById('emptyPerSliceInput');
      if (emptyInput && emptyInput.value && emptyPerSlice !== numOrZero('emptyPerSliceInput')) {
        emptyInput.value = String(emptyPerSlice);
      }
      const payload = {
        title: document.getElementById('title').value || 'çº¢åŒ…é›¨',
        total_pool: yuanToFen(document.getElementById('totalPool').value),
        lucky_ratio: numOrZero('luckyRatioInput'),
        base_ratio: numOrZero('baseRatioInput'),
        tail_top_n: numOrZero('tailTopNInput'),
        rank_segments: numOrZero('rankSegmentsInput'),
        duration_sec: parseInt(document.getElementById('duration').value || '30', 10),
        slice_ms: sliceMsInput,
        drop_visible_ms: numOrZero('dropVisibleMsInput'),
        drops_per_slice: dropsPerSlice,
        bombs_per_slice: bombsPerSlice,
        bigs_per_slice: bigsPerSlice,
        empty_per_slice: emptyPerSlice,
        big_multiplier: parseFloat(document.getElementById('bigMultiplierInput')?.value || '0'),
        max_speed: parseFloat(document.getElementById('maxSpeedInput')?.value || '0'),
        score_total: numOrZero('scoreTotalInput'),
        bomb_penalty: numOrZero('bombPenaltyInput'),
        min_award: yuanToFen(document.getElementById('minAwardInput')?.value || '0'),
        max_award: yuanToFen(document.getElementById('maxAwardInput')?.value || '0'),
      };
      if (payload.lucky_ratio + payload.base_ratio > 100) {
        document.getElementById('createResult').innerText = 'å¹¸è¿æ± æ¯”ä¾‹ + åŸºç¡€æ± æ¯”ä¾‹ ä¸èƒ½è¶…è¿‡ 100%';
        return;
      }
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds`, {
          method: 'POST',
          headers: adminHeaders(),
          body: JSON.stringify(payload)
        });
        const data = await requireOk(res, 'åˆ›å»ºå¤±è´¥');
        document.getElementById('createResult').innerText = JSON.stringify(data);
        if (data.id) {
          currentRoundId = data.id;
          setFollowCurrent(false);
          loadBatches();
          loadRounds();
          refreshLeaderboard();
          pollMetrics();
        }
      } catch (e) {
        document.getElementById('createResult').innerText = `å¤±è´¥ï¼š${e.message || 'åˆ›å»ºå¤±è´¥'}`;
        alert(e.message || 'åˆ›å»ºå¤±è´¥');
      }
    }

    async function lockRound() {
      if (!currentRoundId) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/lock`, { method: 'POST', headers: adminHeaders() });
        await requireOk(res, 'é”å®šå¤±è´¥');
        openLockModal();
        loadRounds();
      } catch (e) {
        alert(e.message || 'é”å®šå¤±è´¥');
      }
    }

    async function startRound() {
      if (!currentRoundId) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/start`, {
          method: 'POST',
          headers: adminHeaders(),
          body: JSON.stringify({ countdown_sec: parseInt(document.getElementById('countdownInput').value || '3', 10) })
        });
        await requireOk(res, 'å¼€å§‹å¤±è´¥');
        loadRounds();
      } catch (e) {
        alert(e.message || 'å¼€å§‹å¤±è´¥');
      }
    }

    async function drawRound() {
      if (!currentRoundId) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/draw`, { method: 'POST', headers: adminHeaders() });
        await requireOk(res, 'å¼€å¥–å¤±è´¥');
        loadBatches();
        loadRounds();
      } catch (e) {
        alert(e.message || 'å¼€å¥–å¤±è´¥');
      }
    }

    // =====================
    // Whitelist
    // =====================
    async function addWhitelist() {
      if (!currentRoundId) return;
      const raw = document.getElementById('whitelistPhones').value;
      const phones = raw.split(/[,\n\r]+/).map(v => v.trim()).filter(Boolean);
      await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/whitelist`, {
        method: 'POST',
        headers: adminHeaders(),
        body: JSON.stringify({ phones })
      });
    }

    async function importAllOnline() {
      if (!currentRoundId) return;
      const filterTokens = splitFilterTokens(lockFilterText);
      let user_ids = [];
      if (lockSelectedIds.size > 0) {
        user_ids = Array.from(lockSelectedIds);
      } else if (filterTokens.length > 0) {
        const filtered = filterOnlineList(onlineUserCache, lockFilterText);
        user_ids = filtered.map(item => item.user_id);
      } else {
        user_ids = onlineUserCache.map(item => item.user_id);
      }
      if (user_ids.length === 0) return;
      await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/whitelist`, {
        method: 'POST',
        headers: adminHeaders(),
        body: JSON.stringify({ user_ids })
      });
      closeLockModal();
    }

    // =====================
    // Lists & Rendering
    // =====================
    function splitFilterTokens(text) {
      return (text || '').trim().split(/\s+/).map(v => v.trim()).filter(Boolean);
    }

    function matchOnlineUser(item, token) {
      if (!token) return false;
      const t = token.toLowerCase();
      const phone = String(item.phone || '').toLowerCase();
      const nickname = String(item.nickname || '').toLowerCase();
      const uid = String(item.user_id || item.id || '').toLowerCase();
      return (phone && phone.includes(t)) || (nickname && nickname.includes(t)) || (uid && uid.includes(t));
    }

    function filterOnlineList(list, filterText) {
      const tokens = splitFilterTokens(filterText);
      if (!tokens.length) return list || [];
      return (list || []).filter(item => tokens.some(token => matchOnlineUser(item, token)));
    }

    function updateLockFilterHint(filteredCount, totalCount) {
      const hint = document.getElementById('lockFilterHint');
      if (!hint) return;
      const selectedCount = lockSelectedIds.size;
      let text = `å·²ç­›é€‰ ${filteredCount}/${totalCount}`;
      if (selectedCount > 0) {
        text += `ï¼Œå·²é€‰ ${selectedCount}`;
      }
      hint.textContent = text;
    }

    function updateLockSelectAllState(filtered) {
      const selectAll = document.getElementById('lockSelectAll');
      if (!selectAll) return;
      const total = filtered.length;
      if (total === 0) {
        selectAll.checked = false;
        selectAll.indeterminate = false;
        return;
      }
      let selected = 0;
      filtered.forEach(item => {
        if (lockSelectedIds.has(item.user_id)) selected += 1;
      });
      if (selected === 0) {
        selectAll.checked = false;
        selectAll.indeterminate = false;
      } else if (selected === total) {
        selectAll.checked = true;
        selectAll.indeterminate = false;
      } else {
        selectAll.checked = false;
        selectAll.indeterminate = true;
      }
    }

    function toggleLockSelectAll(checked) {
      const filtered = filterOnlineList(onlineUserCache, lockFilterText);
      if (checked) {
        filtered.forEach(item => lockSelectedIds.add(item.user_id));
      } else {
        filtered.forEach(item => lockSelectedIds.delete(item.user_id));
      }
      renderOnlineList('lockOnlineUsers', onlineUserCache);
    }

    function toggleLockSelect(uid, checked) {
      const userId = Number(uid);
      if (!userId) return;
      if (checked) {
        lockSelectedIds.add(userId);
      } else {
        lockSelectedIds.delete(userId);
      }
      const filtered = filterOnlineList(onlineUserCache, lockFilterText);
      updateLockSelectAllState(filtered);
      updateLockFilterHint(filtered.length, onlineUserCache.length);
    }

    function applyLockFilter() {
      const input = document.getElementById('lockFilterInput');
      lockFilterText = input ? input.value : '';
      renderOnlineList('lockOnlineUsers', onlineUserCache);
    }

    function renderOnlineList(containerId, list) {
      const el = document.getElementById(containerId);
      if (!el) return;
      const isLock = containerId === 'lockOnlineUsers';
      const source = list || [];
      if (isLock) {
        const idSet = new Set(source.map(item => item.user_id));
        Array.from(lockSelectedIds).forEach(uid => {
          if (!idSet.has(uid)) lockSelectedIds.delete(uid);
        });
      }
      const filtered = isLock ? filterOnlineList(source, lockFilterText) : source;
      if (!filtered || filtered.length === 0) {
        if (isLock && source.length > 0 && splitFilterTokens(lockFilterText).length > 0) {
          el.innerHTML = '<div class="note">æ— åŒ¹é…ç”¨æˆ·</div>';
        } else {
          el.innerHTML = '<div class="note">æš‚æ— åœ¨çº¿ç”¨æˆ·</div>';
        }
        if (isLock) {
          updateLockSelectAllState([]);
          updateLockFilterHint(0, source.length);
        }
        return;
      }
      if (!isLock) {
        el.innerHTML = filtered.map(item => {
          return `<div class="list-item">
      <div class="user-line">
        ${renderAvatar(item)}
        <div>${renderUserName(item)}</div>
      </div>
    </div>`;
        }).join('');
        return;
      }
      el.innerHTML = filtered.map(item => {
        const checked = lockSelectedIds.has(item.user_id) ? 'checked' : '';
        return `<div class="list-item">
      <label class="lock-check">
        <input type="checkbox" ${checked} onchange="toggleLockSelect(${item.user_id}, this.checked)" />
        <div class="user-line">
          ${renderAvatar(item)}
          <div>${renderUserName(item)}</div>
        </div>
      </label>
    </div>`;
      }).join('');
      updateLockSelectAllState(filtered);
      updateLockFilterHint(filtered.length, source.length);
    }

    function renderLeaderboard(items) {
      const el = document.getElementById('leaderboard');
      if (!items || items.length === 0) {
        el.innerHTML = '<div class="note">æš‚æ— æ•°æ®</div>';
        return;
      }
      el.innerHTML = items.map((item, idx) => {
        return `<div class="list-item">
      <div class="user-line">
        ${renderAvatar(item)}
        <div>#${idx + 1} ${renderUserName(item)}</div>
      </div>
      <div style="color:var(--accent); font-weight:600;">${item.score}</div>
    </div>`;
      }).join('');
    }

    function renderRoundSummary(round) {
      const el = document.getElementById('roundSummary');
      if (!round) {
        el.innerHTML = '<div class="note">æš‚æ— </div>';
        return;
      }
      el.innerHTML = `
    <div class="list-item"><span>å¥–æ± </span><span>${(round.total_pool / 100).toFixed(2)} å…ƒ</span></div>
    <div class="list-item"><span>æ—¶é•¿</span><span>${round.duration_sec}s</span></div>
    <div class="list-item"><span>åˆ‡ç‰‡</span><span>${round.slice_ms}ms</span></div>
    <div class="list-item"><span>æ˜¾ç¤ºæ—¶é•¿</span><span>${round.drop_visible_ms || 0}ms</span></div>
    <div class="list-item"><span>æ¯ç‰‡çº¢åŒ…</span><span>${round.drops_per_slice}</span></div>
    <div class="list-item"><span>æ¯ç‰‡ç‚¸å¼¹</span><span>${round.bombs_per_slice}</span></div>
    <div class="list-item"><span>æ¯ç‰‡å¤§çº¢åŒ…</span><span>${round.bigs_per_slice || 0}</span></div>
    <div class="list-item"><span>æ¯ç‰‡ç©ºåŒ…</span><span>${round.empty_per_slice || 0}</span></div>
    <div class="list-item"><span>å¤§çº¢åŒ…å€ç‡</span><span>${round.big_multiplier || 2}</span></div>
    <div class="list-item"><span>æœ€å¤§é€Ÿåº¦</span><span>${round.max_speed || 1.0}</span></div>
    <div class="list-item"><span>æ¯äººå¹¸è¿åˆ†</span><span>${round.score_total}</span></div>
    <div class="list-item"><span>ç‚¸å¼¹æ‰£åˆ†</span><span>${round.bomb_penalty}</span></div>
    <div class="list-item"><span>æœ€å°ä¸­å¥–</span><span>${round.min_award ? (round.min_award / 100).toFixed(2) + ' å…ƒ' : '--'}</span></div>
    <div class="list-item"><span>æœ€å¤§ä¸­å¥–</span><span>${round.max_award ? (round.max_award / 100).toFixed(2) + ' å…ƒ' : '--'}</span></div>
    <div class="list-item"><span>å¹¸è¿æ± æ¯”ä¾‹</span><span>${round.lucky_ratio || 0}%</span></div>
    <div class="list-item"><span>åŸºç¡€æ± æ¯”ä¾‹</span><span>${round.base_ratio || 0}%</span></div>
    <div class="list-item"><span>å°¾å·®è¡¥å¿</span><span>å‰ ${round.tail_top_n || 0} å</span></div>
    <div class="list-item"><span>æ’ååˆ†æ®µ</span><span>${round.rank_segments || 0}</span></div>
  `;
    }

    function withdrawStatusLabel(status) {
      const map = {
        PENDING: 'å¾…å¤„ç†',
        WAITING_FUNDS: 'ä½™é¢ä¸è¶³ç­‰å¾…',
        PROCESSING: 'å¤„ç†ä¸­',
        PAID: 'å·²åˆ°è´¦',
        FAILED: 'å¤±è´¥',
        REFUNDED: 'å·²é€€æ¬¾'
      };
      return map[status] || status || '--';
    }

    function withdrawStatusClass(status) {
      if (status === 'PAID') return 'ok';
      if (status === 'FAILED' || status === 'REFUNDED') return 'danger';
      if (status === 'PROCESSING' || status === 'WAITING_FUNDS') return 'warn';
      return '';
    }

    function renderWithdraws(items) {
      const el = document.getElementById('withdrawListAdmin');
      if (!el) return;
      if (!items || items.length === 0) {
        el.innerHTML = '<div class="note">æš‚æ— æç°è®°å½•</div>';
        return;
      }
      el.innerHTML = items.map(item => {
        const amount = ((item.amount || 0) / 100).toFixed(2);
        const status = item.status || '';
        const statusText = withdrawStatusLabel(status);
        const statusClass = withdrawStatusClass(status);
        const name = escapeHTML(item.alipay_name || '');
        const account = escapeHTML(maskKeep(item.alipay_account || '', 3, 3));
        const idCard = escapeHTML(maskKeep(item.id_card || '', 3, 4));
        const aliStatus = item.alipay_status ? `æ”¯ä»˜å®çŠ¶æ€ï¼š${escapeHTML(item.alipay_status)}` : '';
        const failReason = item.fail_reason ? `å¤±è´¥åŸå› ï¼š${escapeHTML(item.fail_reason)}` : '';
        const createdAt = formatTime(item.created_at);
        const paidAt = item.paid_at ? formatTime(item.paid_at) : '';
        const canTransfer = ['PENDING', 'PROCESSING', 'FAILED'].includes(status);
        const actions = [];
        if (canTransfer) {
          actions.push(`<button class="btn secondary" onclick="transferWithdraw(${item.id})">æ‰“æ¬¾</button>`);
        }
        actions.push(`<button class="btn ghost" onclick="syncWithdraw(${item.id})">åŒæ­¥</button>`);
        return `<div class="list-item" style="flex-direction:column; align-items:flex-start; gap:8px;">
          <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <div class="user-line">
              ${renderAvatar(item)}
              <div>#${item.id} Â· ${renderUserName(item)} Â· Â¥${amount}</div>
            </div>
            <span class="pill ${statusClass}">${statusText}</span>
          </div>
          <div class="meta">æ”¶æ¬¾ï¼š${name} ${account} | ${idCard}</div>
          <div class="meta">åˆ›å»ºï¼š${createdAt}${paidAt ? ` | åˆ°è´¦ï¼š${paidAt}` : ''}</div>
          ${aliStatus || failReason ? `<div class="meta">${aliStatus}${aliStatus && failReason ? ' Â· ' : ''}${failReason}</div>` : ''}
          <div style="display:flex; gap:8px; flex-wrap:wrap;">${actions.join('')}</div>
        </div>`;
      }).join('');
    }

    function prettyPrintRaw(raw) {
      if (!raw) return '';
      if (typeof raw === 'string') {
        try {
          const parsed = JSON.parse(raw);
          return JSON.stringify(parsed, null, 2);
        } catch (e) {
          return raw;
        }
      }
      try {
        return JSON.stringify(raw, null, 2);
      } catch (e) {
        return String(raw);
      }
    }

    function renderAccountSummary(data) {
      const el = document.getElementById('alipayAccountSummary');
      if (!el) return;
      if (!data || typeof data !== 'object') {
        el.innerHTML = '<div class="note">æš‚æ— è´¦æˆ·æ•°æ®</div>';
        return;
      }
      const available = data.available_amount || '--';
      const freeze = data.freeze_amount || '--';
      el.innerHTML = `
        <div class="list-item"><span>å¯ç”¨ä½™é¢</span><span>${available}</span></div>
        <div class="list-item"><span>å†»ç»“é‡‘é¢</span><span>${freeze}</span></div>
      `;
    }

    function updateMetrics(data) {
      setConnStatus('åœ¨çº¿', true);
      const online = data.online_users || 0;
      document.getElementById('onlineCount').innerText = online;
      document.getElementById('onlineBar').style.width = Math.min(100, online / 10) + '%';

      if (data.round) {
        const shouldUpdate = followCurrent || (currentRoundId && data.round.id === currentRoundId);
        if (shouldUpdate) {
          if (followCurrent) {
            currentRoundId = data.round.id;
          }
          currentRoundConfig = data.round;
          roundStatusCache = data.round.status || '';
          document.getElementById('roundTitle').innerText = data.round.title || `è½®æ¬¡#${data.round.id}`;
          document.getElementById('roundMeta').innerText = `çŠ¶æ€ï¼š${roundStatusLabel(data.round.status)} | å¥–æ± ï¼š${(data.round.total_pool / 100).toFixed(2)}å…ƒ`;
          if (data.time_left_ms !== undefined) {
            let leftSec = Math.ceil(data.time_left_ms / 1000);
            if (data.round.status === 'COUNTDOWN' && data.round.start_at && data.server_time) {
              leftSec = Math.max(0, Math.ceil((data.round.start_at - data.server_time) / 1000));
            }
            document.getElementById('timeLeft').innerText = `${leftSec}s`;
          }
          renderRoundSummary(data.round);
          updateFlowHint(data.round);
        }
      } else {
        roundStatusCache = '';
        updateFlowHint(null);
      }

      const qpsAvg = data.qps_avg || 0;
      const qps1s = data.qps_1s || 0;
      document.getElementById('qpsValue').innerText = qpsAvg;
      document.getElementById('qpsDetail').innerText = `${qpsAvg} / ${qps1s}`;
      const avgEl = document.getElementById('qpsAvgText');
      const peakEl = document.getElementById('qpsPeakText');
      if (avgEl) avgEl.innerText = qpsAvg;
      if (peakEl) peakEl.innerText = qps1s;
      pushSeries(qpsSeries, qpsAvg);
      drawSparkline('qpsChart', qpsSeries, '#f4d35e');
    }

    function updateLiveMetrics(data) {
      lastLiveMetrics = data || null;
      const round = data.round || null;
      if (round && round.id) {
        const prevId = liveRoundId;
        liveRoundId = round.id;
        liveRoundConfig = round;
        liveRoundStatus = round.status || '';
        liveScoreUsers = typeof data.score_users === 'number' ? data.score_users : liveScoreUsers;
        updateBigScreen(data);
        if (prevId !== liveRoundId) {
          liveLeaderboardCache = [];
          lastNonEmptyLiveLeaderboard = [];
          renderBigLeaderboard([], liveRoundStatus);
          refreshLiveLeaderboard();
        }
      } else {
        liveRoundId = null;
        liveRoundConfig = null;
        liveRoundStatus = '';
        liveLeaderboardCache = [];
        liveScoreUsers = 0;
        lastSummaryKey = '';
        updateBigScreen({ round: null, server_time: data.server_time });
      }
    }

    function drawSparkline(canvasId, data, color) {
      const canvas = document.getElementById(canvasId);
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      const parentWidth = canvas.parentElement?.clientWidth || 0;
      if (parentWidth <= 0) return;
      const w = canvas.width = parentWidth - 24;
      const h = canvas.height = 110;
      ctx.clearRect(0, 0, w, h);
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      if (data.length === 0) return;
      const max = Math.max(...data, 1);
      const min = Math.min(...data, 0);
      const range = max - min || 1;
      ctx.beginPath();
      data.forEach((v, i) => {
        const x = (i / (data.length - 1 || 1)) * w;
        const y = h - ((v - min) / range) * h;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      });
      ctx.stroke();
    }

    // =====================
    // Data Fetching
    // =====================
    async function loadBatches() {
      const [batchRes, roundRes] = await Promise.all([
        fetch(`${apiBase}/api/admin/award_batches`, { headers: adminHeaders() }),
        fetch(`${apiBase}/api/admin/rounds?limit=50`, { headers: adminHeaders() })
      ]);
      const batchData = await batchRes.json();
      const roundData = await roundRes.json();
      const list = batchData.items || [];
      const rounds = roundData.items || [];
      const pendingRounds = rounds.filter(item => ['READY_DRAW', 'DRAWING'].includes(item.status));
      const pendingItems = pendingRounds.map(item => ({
        id: `round-${item.id}`,
        round_id: item.id,
        total_pool: item.total_pool,
        status: item.status,
        created_at: item.end_at || item.updated_at || item.created_at,
        is_round: true
      }));
      const merged = [...pendingItems, ...list];
      const el = document.getElementById('batchList');
      if (!merged.length) {
        el.innerHTML = '<div class="note">æš‚æ— æ‰¹æ¬¡</div>';
        return;
      }
      el.innerHTML = merged.map(item => {
        const statusLabel = batchStatusLabel(item.status);
        const statusClass = batchStatusClass(item.status);
        const pool = ((item.total_pool || 0) / 100).toFixed(2);
        const createdAt = formatTime(item.created_at);
        const isRound = !!item.is_round;
        const canConfirm = !isRound && item.status === 'PENDING_CONFIRM';
        const canVoid = !isRound && item.status !== 'CONFIRMED' && item.status !== 'VOID';
        const canDraw = isRound && item.status === 'READY_DRAW';
        const title = isRound ? `è½®æ¬¡#${item.round_id}` : `æ‰¹æ¬¡#${item.id} Â· è½®æ¬¡#${item.round_id}`;
        return `<div class="list-item" style="flex-direction:column; align-items:flex-start; gap:8px;">
      <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
        <div>${title}</div>
        <span class="status-tag ${statusClass}">${statusLabel}</span>
      </div>
      <div class="meta">å¥–æ± ï¼š${pool} å…ƒ ${createdAt !== '--' ? `| åˆ›å»ºï¼š${createdAt}` : ''}</div>
      <div style="display:flex; gap:8px;">
        ${canDraw ? `<button class="btn primary" onclick="drawRoundById(${item.round_id})">å¼€å¥–</button>` : ''}
        ${canConfirm ? `<button class="btn ghost" onclick="confirmBatch(${item.id})">ç¡®è®¤å…¥è´¦</button>` : ''}
        ${canVoid ? `<button class="btn danger" onclick="voidBatch(${item.id})">ä½œåºŸ</button>` : ''}
      </div>
    </div>`;
      }).join('');
    }

    async function loadRoundResults(reset = false) {
      if (!currentRoundId) {
        const summary = document.getElementById('roundResultSummary');
        const list = document.getElementById('roundResultList');
        if (summary) summary.innerText = 'é€‰æ‹©å†å²è½®æ¬¡æŸ¥çœ‹';
        if (list) list.innerHTML = '<div class="note">æš‚æ— æ•°æ®</div>';
        return;
      }
      if (reset) {
        roundResultOffset = 0;
      }
      const input = document.getElementById('roundResultSearch');
      const q = input ? input.value.trim() : '';
      const url = `${apiBase}/api/admin/rounds/${currentRoundId}/results?limit=${roundResultLimit}&offset=${roundResultOffset}&q=${encodeURIComponent(q)}`;
      try {
        const res = await fetch(url, { headers: adminHeaders() });
        const data = await requireOk(res, 'åŠ è½½è½®æ¬¡ç»“æœå¤±è´¥');
        roundResultTotal = data.total || 0;
        const items = data.items || [];
        renderRoundResults(items, data);
      } catch (e) {
        const summary = document.getElementById('roundResultSummary');
        const list = document.getElementById('roundResultList');
        if (summary) summary.innerText = e.message || 'åŠ è½½å¤±è´¥';
        if (list) list.innerHTML = '<div class="note">åŠ è½½å¤±è´¥</div>';
      }
    }

    function renderRoundResults(items, meta) {
      const summary = document.getElementById('roundResultSummary');
      const listEl = document.getElementById('roundResultList');
      if (!summary || !listEl) return;
      const scoreSum = meta?.score_sum || 0;
      const scoreUsers = meta?.score_users || 0;
      const start = roundResultOffset + 1;
      const end = roundResultOffset + (items ? items.length : 0);
      summary.innerText = `è½®æ¬¡ #${currentRoundId} Â· æ€»åˆ†å€¼ ${scoreSum} Â· ç”¨æˆ· ${scoreUsers} Â· æ˜¾ç¤º ${start}-${end}`;
      if (!items || items.length === 0) {
        listEl.innerHTML = '<div class="note">æš‚æ— æ•°æ®</div>';
        return;
      }
      listEl.innerHTML = items.map(item => {
        const amount = ((item.amount || 0) / 100).toFixed(2);
        const baseAmount = ((item.base_amount || 0) / 100).toFixed(2);
        const luckyAmount = ((item.lucky_amount || 0) / 100).toFixed(2);
        return `<div class="list-item" style="flex-direction:column; align-items:flex-start; gap:8px;">
      <div class="user-line">
        ${renderAvatar(item, 'mini')}
        <div>#${item.rank} ${renderUserName(item)}</div>
      </div>
      <div class="meta">åˆ†å€¼ï¼š${item.score} Â· é‡‘é¢ï¼š${amount} å…ƒï¼ˆåŸºç¡€ ${baseAmount} / å¹¸è¿ ${luckyAmount}ï¼‰</div>
    </div>`;
      }).join('');
    }

    function prevRoundResultPage() {
      if (roundResultOffset <= 0) return;
      roundResultOffset = Math.max(0, roundResultOffset - roundResultLimit);
      loadRoundResults(false);
    }

    function nextRoundResultPage() {
      if (roundResultOffset + roundResultLimit >= roundResultTotal) return;
      roundResultOffset += roundResultLimit;
      loadRoundResults(false);
    }

    async function confirmBatch(id) {
      try {
        const res = await fetch(`${apiBase}/api/admin/award_batches/${id}/confirm`, { method: 'POST', headers: adminHeaders() });
        await requireOk(res, 'ç¡®è®¤å¤±è´¥');
        loadBatches();
        loadRounds();
      } catch (e) {
        alert(e.message || 'ç¡®è®¤å¤±è´¥');
      }
    }

    async function drawRoundById(id) {
      if (!id) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${id}/draw`, { method: 'POST', headers: adminHeaders() });
        await requireOk(res, 'å¼€å¥–å¤±è´¥');
        loadBatches();
        loadRounds();
      } catch (e) {
        alert(e.message || 'å¼€å¥–å¤±è´¥');
      }
    }

    async function voidBatch(id) {
      if (!confirm(`ç¡®è®¤ä½œåºŸæ‰¹æ¬¡ #${id} å—ï¼Ÿ`)) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/award_batches/${id}/void`, { method: 'POST', headers: adminHeaders() });
        await requireOk(res, 'ä½œåºŸå¤±è´¥');
        loadBatches();
        loadRounds();
      } catch (e) {
        alert(e.message || 'ä½œåºŸå¤±è´¥');
      }
    }

    async function loadRounds() {
      const res = await fetch(`${apiBase}/api/admin/rounds`, { headers: adminHeaders() });
      const data = await res.json();
      const list = data.items || [];
      const el = document.getElementById('roundList');
      if (!list.length) {
        el.innerHTML = '<div class="note">æš‚æ— å†å²è½®æ¬¡</div>';
        return;
      }
      el.innerHTML = list.map(item => {
        const statusLabel = roundStatusLabel(item.status);
        const statusClass = roundStatusClass(item.status);
        const canDelete = item.status === 'WAITING' || item.status === 'LOCKED';
        return `<div class="list-item">
      <div>#${item.id} ${escapeHTML(item.title || 'çº¢åŒ…é›¨')} <span class="status-tag ${statusClass}">${statusLabel}</span></div>
      <div style="display:flex; gap:8px;">
        <button class="btn ghost" onclick='selectRound(${item.id})'>æŸ¥çœ‹</button>
        <button class="btn ghost" onclick='exportRound(${item.id})'>å¯¼å‡º</button>
        ${canDelete ? `<button class="btn danger" onclick='deleteRound(${item.id})'>åˆ é™¤</button>` : ''}
      </div>
    </div>`;
      }).join('');
    }

    async function deleteRound(id) {
      if (!confirm(`ç¡®è®¤åˆ é™¤è½®æ¬¡ #${id} å—ï¼Ÿä»…å…è®¸æœªå¼€å§‹çš„è½®æ¬¡åˆ é™¤ã€‚`)) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${id}`, { method: 'DELETE', headers: adminHeaders() });
        await requireOk(res, 'åˆ é™¤å¤±è´¥');
        if (currentRoundId === id) {
          currentRoundId = null;
        }
        loadRounds();
        loadBatches();
      } catch (e) {
        alert(e.message || 'åˆ é™¤å¤±è´¥');
      }
    }

    async function exportRound(id) {
      const btnText = `å¯¼å‡ºè½®æ¬¡#${id}`;
      try {
        const res = await fetch(`${apiBase}/api/admin/rounds/${id}/export`, { headers: adminHeaders() });
        if (!res.ok) {
          const text = await res.text();
          throw new Error(text || 'å¯¼å‡ºå¤±è´¥');
        }
        const blob = await res.blob();
        const disposition = res.headers.get('content-disposition') || '';
        let filename = `round_${id}.csv`;
        const match = disposition.match(/filename="?([^"]+)"?/i);
        if (match && match[1]) filename = match[1];
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = filename;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
      } catch (e) {
        alert(`${btnText}å¤±è´¥ï¼š${e.message || 'æœªçŸ¥é”™è¯¯'}`);
      }
    }

    function setWithdrawSwitchUI(enabled) {
      const input = document.getElementById('withdrawSwitch');
      const text = document.getElementById('withdrawSwitchText');
      const hint = document.getElementById('withdrawSwitchHint');
      if (input) input.checked = !!enabled;
      if (text) text.innerText = enabled ? 'å·²å¼€å¯' : 'å·²å…³é—­';
      if (hint) hint.innerText = enabled ? 'ç”¨æˆ·ç«¯å¯æäº¤æç°ç”³è¯·ã€‚' : 'å·²æš‚åœæç°ç”³è¯·ï¼ˆç”¨æˆ·ç«¯å°†æ— æ³•æäº¤ï¼‰ã€‚';
    }

    async function loadWithdrawSwitch() {
      const input = document.getElementById('withdrawSwitch');
      if (!input) return;
      try {
        const res = await fetch(`${apiBase}/api/admin/withdraw_switch`, { headers: adminHeaders() });
        const data = await res.json();
        setWithdrawSwitchUI(!!data.enabled);
      } catch (e) {
        setWithdrawSwitchUI(false);
      }
    }

    async function updateWithdrawSwitch(enabled) {
      try {
        const res = await fetch(`${apiBase}/api/admin/withdraw_switch`, {
          method: 'POST',
          headers: adminHeaders(),
          body: JSON.stringify({ enabled: !!enabled })
        });
        const data = await res.json();
        if (data.error) {
          throw new Error(data.error);
        }
        setWithdrawSwitchUI(!!data.enabled);
      } catch (e) {
        alert(e.message || 'æ›´æ–°æç°å¼€å…³å¤±è´¥');
        loadWithdrawSwitch();
      }
    }

    async function loadWithdrawsAdmin(reset = false) {
      if (reset) {
        withdrawOffset = 0;
      }
      const status = document.getElementById('withdrawStatusFilter')?.value || '';
      const limit = parseInt(document.getElementById('withdrawLimit')?.value || '20', 10);
      const url = `${apiBase}/api/admin/withdraws?status=${encodeURIComponent(status)}&limit=${limit}&offset=${withdrawOffset}`;
      const res = await fetch(url, { headers: adminHeaders() });
      const data = await res.json();
      if (data.error) {
        const meta = document.getElementById('withdrawMeta');
        if (meta) meta.innerText = data.error;
        const queueHint = document.getElementById('withdrawQueueHint');
        if (queueHint) queueHint.innerText = data.error;
        renderWithdraws([]);
        return;
      }
      const items = data.items || [];
      withdrawLastCount = items.length;
      renderWithdraws(items);
      const meta = document.getElementById('withdrawMeta');
      if (meta) {
        meta.innerText = `å·²åŠ è½½ ${items.length} æ¡ | offset ${withdrawOffset}`;
      }
      const queueHint = document.getElementById('withdrawQueueHint');
      if (queueHint) {
        const statusLabel = withdrawStatusLabel(status) || 'å…¨éƒ¨';
        queueHint.innerText = `å½“å‰ç­›é€‰ï¼š${statusLabel} Â· æœ¬é¡µ ${items.length} æ¡`;
      }
    }

    function prevWithdrawPage() {
      const limit = parseInt(document.getElementById('withdrawLimit')?.value || '20', 10);
      withdrawOffset = Math.max(0, withdrawOffset - limit);
      loadWithdrawsAdmin();
    }

    function nextWithdrawPage() {
      const limit = parseInt(document.getElementById('withdrawLimit')?.value || '20', 10);
      if (withdrawLastCount < limit) return;
      withdrawOffset += limit;
      loadWithdrawsAdmin();
    }

    async function transferWithdraw(id) {
      await fetch(`${apiBase}/api/admin/withdraws/${id}/transfer`, {
        method: 'POST',
        headers: adminHeaders()
      });
      loadWithdrawsAdmin();
    }

    async function syncWithdraw(id) {
      await fetch(`${apiBase}/api/admin/withdraws/${id}/sync`, {
        method: 'POST',
        headers: adminHeaders()
      });
      loadWithdrawsAdmin();
    }

    async function queryAlipayAccount() {
      const userId = document.getElementById('alipayUserIdInput')?.value?.trim() || '';
      const accountType = document.getElementById('alipayAccountTypeInput')?.value?.trim() || '';
      const url = `${apiBase}/api/admin/alipay/account?alipay_user_id=${encodeURIComponent(userId)}&account_type=${encodeURIComponent(accountType)}`;
      const res = await fetch(url, { headers: adminHeaders() });
      const data = await res.json();
      if (data.error) {
        const box = document.getElementById('alipayAccountResult');
        if (box) box.value = data.error;
        renderAccountSummary(null);
        return;
      }
      const raw = data.raw || data;
      const box = document.getElementById('alipayAccountResult');
      if (box) box.value = prettyPrintRaw(raw);
      let parsed = raw;
      if (typeof raw === 'string') {
        try {
          parsed = JSON.parse(raw);
        } catch (e) {
          parsed = null;
        }
      }
      renderAccountSummary(parsed);
    }

    async function queryAlipayQuota() {
      const productCode = document.getElementById('alipayProductCodeInput')?.value?.trim() || '';
      const bizScene = document.getElementById('alipayBizSceneInput')?.value?.trim() || '';
      const url = `${apiBase}/api/admin/alipay/quota?product_code=${encodeURIComponent(productCode)}&biz_scene=${encodeURIComponent(bizScene)}`;
      const res = await fetch(url, { headers: adminHeaders() });
      const data = await res.json();
      const raw = data.raw || data;
      const box = document.getElementById('alipayQuotaResult');
      if (box) box.value = prettyPrintRaw(raw);
    }

    async function transferTest() {
      const account = document.getElementById('alipayTestAccountInput')?.value?.trim() || '';
      const name = document.getElementById('alipayTestNameInput')?.value?.trim() || '';
      const amountYuan = document.getElementById('alipayTestAmountInput')?.value?.trim() || '';
      const sceneType = document.getElementById('alipaySceneInfoTypeInput')?.value?.trim() || '';
      const sceneContent = document.getElementById('alipaySceneInfoContentInput')?.value?.trim() || '';
      const sceneReportRaw = document.getElementById('alipaySceneReportJson')?.value?.trim() || '';
      const box = document.getElementById('alipayTransferResult');
      if (!account || !name) {
        if (box) box.value = 'è¯·å¡«å†™æ”¶æ¬¾è´¦å·ä¸å§“å';
        return;
      }
      let reportInfos = [];
      if (sceneReportRaw) {
        try {
          const parsed = JSON.parse(sceneReportRaw);
          if (Array.isArray(parsed)) {
            reportInfos = parsed;
          } else {
            throw new Error('è½¬è´¦åœºæ™¯ä¸ŠæŠ¥ä¿¡æ¯éœ€è¦ä¸º JSON æ•°ç»„');
          }
        } catch (e) {
          if (box) box.value = e.message || 'è½¬è´¦åœºæ™¯ä¸ŠæŠ¥ä¿¡æ¯ JSON æ ¼å¼é”™è¯¯';
          return;
        }
      } else if (sceneType && sceneContent) {
        reportInfos = [{ info_type: sceneType, info_content: sceneContent }];
      }
      const url = `${apiBase}/api/admin/alipay/transfer_test`;
      const res = await fetch(url, {
        method: 'POST',
        headers: adminHeaders(),
        body: JSON.stringify({ payee_account: account, payee_name: name, amount_yuan: amountYuan, transfer_scene_report_infos: reportInfos })
      });
      const data = await res.json();
      if (box) box.value = prettyPrintRaw(data);
    }

    async function selectRound(id) {
      currentRoundId = id;
      setFollowCurrent(false);
      await refreshLeaderboard();
      await pollMetrics();
      const summary = document.getElementById('roundResultSummary');
      if (summary) summary.innerText = 'åŠ è½½ä¸­...';
      loadRoundResults(true);
    }

    async function loadOnlineUsers(containerId = 'onlineUsers') {
      const res = await fetch(`${apiBase}/api/admin/online_users`, { headers: adminHeaders() });
      const data = await res.json();
      const list = data.items || [];
      onlineUserCache = list;
      renderOnlineList(containerId, list);
    }

    async function loadLeaderboard(limit = 10) {
      if (!currentRoundId) return;
      leaderboardLimit = limit;
      const res = await fetch(`${apiBase}/api/admin/rounds/${currentRoundId}/leaderboard?limit=${limit}`, { headers: adminHeaders() });
      const data = await res.json();
      const items = data.items || [];
      leaderboardCache = items;
      renderLeaderboard(items.slice(0, 10));
      const topScore = items.length ? items[0].score : 0;
      pushSeries(scoreSeries, topScore);
      drawSparkline('scoreChart', scoreSeries, '#37e2c9');
    }

    function desiredLeaderboardLimit() {
      if (['READY_DRAW', 'DRAWING', 'PENDING_CONFIRM', 'FINISHED'].includes(roundStatusCache)) {
        return 100;
      }
      return 10;
    }

    async function refreshLeaderboard() {
      const limit = desiredLeaderboardLimit();
      await loadLeaderboard(limit);
    }

    function desiredLiveLeaderboardLimit() {
      const wanted = liveScoreUsers || 0;
      const base = Math.max(10, wanted);
      return Math.min(base, 1000);
    }

    async function loadLiveLeaderboard(limit = 10) {
      if (!liveRoundId) {
        liveLeaderboardCache = [];
        renderBigLeaderboard([], liveRoundStatus);
        return;
      }
      liveLeaderboardLimit = limit;
      const res = await fetch(`${apiBase}/api/admin/rounds/${liveRoundId}/leaderboard?limit=${limit}`, { headers: adminHeaders() });
      const data = await res.json();
      const items = data.items || [];
      const isFinal = ['READY_DRAW', 'DRAWING', 'PENDING_CONFIRM', 'FINISHED'].includes(liveRoundStatus);
      if (items.length > 0) {
        lastNonEmptyLiveLeaderboard = items;
      }
      const effectiveItems = (items.length === 0 && isFinal && lastNonEmptyLiveLeaderboard.length > 0)
        ? lastNonEmptyLiveLeaderboard
        : items;
      if (!leaderboardChanged(liveLeaderboardCache, effectiveItems)) {
        return;
      }
      liveLeaderboardCache = effectiveItems;
      const lanesEl = document.getElementById('raceLanes');
      const prevScroll = lanesEl ? lanesEl.scrollTop : 0;
      renderBigLeaderboard(effectiveItems, liveRoundStatus);
      if (lanesEl) {
        lanesEl.scrollTop = prevScroll;
      }
    }

    async function refreshLiveLeaderboard() {
      const limit = desiredLiveLeaderboardLimit();
      await loadLiveLeaderboard(limit);
    }

    async function pollMetrics() {
      let url = `${apiBase}/api/admin/metrics`;
      if (!followCurrent && currentRoundId) {
        url += `?round_id=${currentRoundId}`;
      }
      const res = await fetch(url, { headers: adminHeaders() });
      const data = await res.json();
      updateMetrics(data);
    }

    async function pollLiveMetrics() {
      const res = await fetch(`${apiBase}/api/admin/metrics`, { headers: adminHeaders() });
      const data = await res.json();
      updateLiveMetrics(data);
    }

    function startPolling() {
      if (pollTimer) return;
      pollMetrics().then(refreshLeaderboard);
      pollLiveMetrics().then(refreshLiveLeaderboard);
      loadBatches();
      loadRounds();
      loadOnlineUsers();
      loadWithdrawsAdmin(true);
      loadWithdrawSwitch();
      if (!leaderboardTimer) {
        leaderboardTimer = setInterval(async () => {
          if (leaderboardLock) return; // ä¸Šä¸€æ¬¡è¯·æ±‚æœªå®Œæˆï¼Œè·³è¿‡
          leaderboardLock = true;
          try {
            await refreshLiveLeaderboard();
            await refreshLeaderboard();
          } finally {
            leaderboardLock = false;
          }
        }, 300);
      }
      pollTimer = setInterval(async () => {
        if (pollLock) return; // ä¸Šä¸€æ¬¡è¯·æ±‚æœªå®Œæˆï¼Œè·³è¿‡
        pollLock = true;
        try {
          await pollLiveMetrics();
          await pollMetrics();
          if (!onlineUsersLock) {
            onlineUsersLock = true;
            loadOnlineUsers().finally(() => { onlineUsersLock = false; });
          }
          withdrawTick += 1;
          if (withdrawTick % 6 === 0 && !withdrawsLock) {
            withdrawsLock = true;
            loadWithdrawsAdmin().finally(() => { withdrawsLock = false; });
          }
        } finally {
          pollLock = false;
        }
      }, 2000);
    }

    (function initDifficultyState() {
      const select = document.getElementById('difficultySelect');
      if (select && select.value) {
        lastDifficultyKey = select.value;
      }
    })();

    // =====================
    // Modals
    // =====================
    function openLockModal() {
      const modal = document.getElementById('lockModal');
      modal.classList.add('active');
      lockFilterText = '';
      lockSelectedIds.clear();
      const input = document.getElementById('lockFilterInput');
      if (input) input.value = '';
      const selectAll = document.getElementById('lockSelectAll');
      if (selectAll) {
        selectAll.checked = false;
        selectAll.indeterminate = false;
      }
      updateLockFilterHint(0, onlineUserCache.length);
      loadOnlineUsers('lockOnlineUsers');
    }

    function closeLockModal() {
      const modal = document.getElementById('lockModal');
      modal.classList.remove('active');
    }

    // =====================
    // Clipboard
    // =====================
    function copyConfig() {
      if (!currentRoundConfig) return;
      const cfg = {
        title: currentRoundConfig.title,
        total_pool: currentRoundConfig.total_pool,
        duration_sec: currentRoundConfig.duration_sec,
        slice_ms: currentRoundConfig.slice_ms,
        drop_visible_ms: currentRoundConfig.drop_visible_ms || 0,
        drops_per_slice: currentRoundConfig.drops_per_slice,
        bombs_per_slice: currentRoundConfig.bombs_per_slice,
        bigs_per_slice: currentRoundConfig.bigs_per_slice || 0,
        empty_per_slice: currentRoundConfig.empty_per_slice || 0,
        big_multiplier: currentRoundConfig.big_multiplier || 2,
        max_speed: currentRoundConfig.max_speed || 1.0,
        score_total: currentRoundConfig.score_total,
        bomb_penalty: currentRoundConfig.bomb_penalty,
        min_award: currentRoundConfig.min_award,
        max_award: currentRoundConfig.max_award,
        lucky_ratio: currentRoundConfig.lucky_ratio,
        base_ratio: currentRoundConfig.base_ratio,
        tail_top_n: currentRoundConfig.tail_top_n,
        rank_segments: currentRoundConfig.rank_segments
      };
      navigator.clipboard.writeText(JSON.stringify(cfg, null, 2));
    }

    // =====================
    // System Reset
    // =====================
    async function resetAllData() {
      const secret = document.getElementById('initSecretInput')?.value?.trim();
      const resultEl = document.getElementById('resetResult');
      if (!secret) {
        resultEl.innerHTML = '<span style="color:#e74c3c;">è¯·è¾“å…¥åˆå§‹åŒ–å¯†é’¥</span>';
        return;
      }
      if (!confirm('âš ï¸ ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰æ•°æ®å—ï¼Ÿæ­¤æ“ä½œä¸å¯æ’¤é”€ï¼\\n\\nå°†æ¸…ç©ºï¼šç”¨æˆ·ã€è½®æ¬¡ã€è¯„åˆ†ã€é’±åŒ…ã€æç°è®°å½•ç­‰æ‰€æœ‰æ•°æ®ã€‚')) {
        return;
      }
      if (!confirm('ğŸš¨ å†æ¬¡ç¡®è®¤ï¼šè¿™å°†åˆ é™¤æ‰€æœ‰æ•°æ®å¹¶é‡ç½®è‡ªå¢IDï¼Œç¡®å®šç»§ç»­ï¼Ÿ')) {
        return;
      }
      resultEl.innerHTML = '<span style="color:#3498db;">æ­£åœ¨æ¸…ç©ºæ•°æ®...</span>';
      try {
        const res = await fetch(`${apiBase}/api/admin/init/reset`, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'X-Init-Secret': secret
          }
        });
        const data = await res.json();
        if (!res.ok) {
          resultEl.innerHTML = `<span style="color:#e74c3c;">å¤±è´¥ï¼š${data.error || 'æœªçŸ¥é”™è¯¯'}</span>`;
          return;
        }
        resultEl.innerHTML = '<span style="color:#27ae60;">âœ… æ•°æ®å·²æ¸…ç©ºï¼æ‰€æœ‰è¡¨å·²é‡ç½®ã€‚</span>';
        document.getElementById('initSecretInput').value = '';
        // åˆ·æ–°é¡µé¢æ•°æ®
        loadRounds();
        loadBatches();
        loadOnlineUsers();
        loadWithdrawsAdmin(true);
      } catch (e) {
        resultEl.innerHTML = `<span style="color:#e74c3c;">è¯·æ±‚å¤±è´¥ï¼š${e.message}</span>`;
      }
    }

    // =====================
    // Init
    // =====================
    window.addEventListener('load', () => {
      initTabs();
      refreshDifficultyHint();
      applyPreset();
      updateRatioHint();
      document.getElementById('luckyRatioInput')?.addEventListener('input', updateRatioHint);
      document.getElementById('baseRatioInput')?.addEventListener('input', updateRatioHint);
      document.getElementById('withdrawStatusFilter')?.addEventListener('change', () => loadWithdrawsAdmin(true));
      document.getElementById('withdrawLimit')?.addEventListener('change', () => loadWithdrawsAdmin(true));
      document.getElementById('withdrawSwitch')?.addEventListener('change', (e) => updateWithdrawSwitch(e.target.checked));
      updateFlowHint(null);
      if (getToken()) {
        setConnStatus('å·²ç™»å½•');
        startPolling();
      }
    });
  </script>
</body>

</html>
